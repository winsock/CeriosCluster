<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<title>MySQL++ Reference Manual</title>
	<meta http-equiv="Content-type" content="text/html;charset=iso-8859-1">
	<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body>
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>mysqlpp</b></li><li class="navelem"><a class="el" href="classmysqlpp_1_1Query.html">Query</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmysqlpp_1_1Query-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mysqlpp::Query Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class for building and executing SQL queries.  
 <a href="classmysqlpp_1_1Query.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="query_8h_source.html">query.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mysqlpp::Query:</div>
<div class="dyncontent">
<div class="center"><img src="classmysqlpp_1_1Query__inherit__graph.png" border="0" usemap="#mysqlpp_1_1Query_inherit__map" alt="Inheritance graph"/></div>
<map name="mysqlpp_1_1Query_inherit__map" id="mysqlpp_1_1Query_inherit__map">
<area shape="rect" id="node3" href="classmysqlpp_1_1OptionalExceptions.html" title="Interface allowing a class to have optional exceptions. " alt="" coords="124,5,316,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mysqlpp::Query:</div>
<div class="dyncontent">
<div class="center"><img src="classmysqlpp_1_1Query__coll__graph.png" border="0" usemap="#mysqlpp_1_1Query_coll__map" alt="Collaboration graph"/></div>
<map name="mysqlpp_1_1Query_coll__map" id="mysqlpp_1_1Query_coll__map">
<area shape="rect" id="node3" href="classmysqlpp_1_1OptionalExceptions.html" title="Interface allowing a class to have optional exceptions. " alt="" coords="124,83,316,109"/><area shape="rect" id="node4" href="classmysqlpp_1_1SQLQueryParms.html" title="This class holds the parameter values for filling template queries. " alt="" coords="340,83,519,109"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query_1_1MaxPacketInsertPolicy.html">MaxPacketInsertPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An insert policy object that triggers a new INSERT statement if the object to be added would cause the statement to exceed a maximum size.  <a href="classmysqlpp_1_1Query_1_1MaxPacketInsertPolicy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query_1_1RowCountInsertPolicy.html">RowCountInsertPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An insert policy object that triggers a new INSERT statement after a given number of rows have been inserted.  <a href="classmysqlpp_1_1Query_1_1RowCountInsertPolicy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query_1_1SizeThresholdInsertPolicy.html">SizeThresholdInsertPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An insert policy object that triggers a new INSERT statement after a size threshold for the length of the INSERT statement is exceeded.  <a href="classmysqlpp_1_1Query_1_1SizeThresholdInsertPolicy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6c6cbae18ebcb31b6d44e7784d5a3daa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a6c6cbae18ebcb31b6d44e7784d5a3daa">Query</a> (<a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> *c, bool te=true, const char *qstr=0)</td></tr>
<tr class="memdesc:a6c6cbae18ebcb31b6d44e7784d5a3daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new query object attached to a connection.  <a href="#a6c6cbae18ebcb31b6d44e7784d5a3daa">More...</a><br/></td></tr>
<tr class="separator:a6c6cbae18ebcb31b6d44e7784d5a3daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936b1062bb31b3428ead059a26590b6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a936b1062bb31b3428ead059a26590b6b">Query</a> (const <a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;q)</td></tr>
<tr class="memdesc:a936b1062bb31b3428ead059a26590b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new query object as a copy of another.  <a href="#a936b1062bb31b3428ead059a26590b6b">More...</a><br/></td></tr>
<tr class="separator:a936b1062bb31b3428ead059a26590b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d0b71c5cb23f70ebc0d27f0ecc3adc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80d0b71c5cb23f70ebc0d27f0ecc3adc"></a>
ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a80d0b71c5cb23f70ebc0d27f0ecc3adc">affected_rows</a> ()</td></tr>
<tr class="memdesc:a80d0b71c5cb23f70ebc0d27f0ecc3adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of rows affected by the last query. <br/></td></tr>
<tr class="separator:a80d0b71c5cb23f70ebc0d27f0ecc3adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7d259cbf78f1e418b7ad12751c5342"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#adc7d259cbf78f1e418b7ad12751c5342">escape_string</a> (std::string *ps, const char *original=0, size_t length=0) const </td></tr>
<tr class="memdesc:adc7d259cbf78f1e418b7ad12751c5342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a SQL-escaped version of a character buffer.  <a href="#adc7d259cbf78f1e418b7ad12751c5342">More...</a><br/></td></tr>
<tr class="separator:adc7d259cbf78f1e418b7ad12751c5342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9061afbd8f1c03751b92b8ec6ba0de9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#ab9061afbd8f1c03751b92b8ec6ba0de9">escape_string</a> (char *escaped, const char *original, size_t length) const </td></tr>
<tr class="memdesc:ab9061afbd8f1c03751b92b8ec6ba0de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a SQL-escaped version of the given character buffer.  <a href="#ab9061afbd8f1c03751b92b8ec6ba0de9">More...</a><br/></td></tr>
<tr class="separator:ab9061afbd8f1c03751b92b8ec6ba0de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acf442e091bdfb5344cbe9990f05f3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a3acf442e091bdfb5344cbe9990f05f3b">errnum</a> () const </td></tr>
<tr class="memdesc:a3acf442e091bdfb5344cbe9990f05f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last error number that was set.  <a href="#a3acf442e091bdfb5344cbe9990f05f3b">More...</a><br/></td></tr>
<tr class="separator:a3acf442e091bdfb5344cbe9990f05f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ddaff8ae037c56c1a5aceda34e89c8"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a24ddaff8ae037c56c1a5aceda34e89c8">error</a> () const </td></tr>
<tr class="memdesc:a24ddaff8ae037c56c1a5aceda34e89c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last error message that was set.  <a href="#a24ddaff8ae037c56c1a5aceda34e89c8">More...</a><br/></td></tr>
<tr class="separator:a24ddaff8ae037c56c1a5aceda34e89c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecef4fce9f76f19ee82ad5a4bece19f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afecef4fce9f76f19ee82ad5a4bece19f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#afecef4fce9f76f19ee82ad5a4bece19f">info</a> ()</td></tr>
<tr class="memdesc:afecef4fce9f76f19ee82ad5a4bece19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information about the most recently executed query. <br/></td></tr>
<tr class="separator:afecef4fce9f76f19ee82ad5a4bece19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15198c894157a099154be69201b5baf"><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#aa15198c894157a099154be69201b5baf">insert_id</a> ()</td></tr>
<tr class="memdesc:aa15198c894157a099154be69201b5baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ID generated for an AUTO_INCREMENT column in the previous INSERT query.  <a href="#aa15198c894157a099154be69201b5baf">More...</a><br/></td></tr>
<tr class="separator:aa15198c894157a099154be69201b5baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75982ff4f3b5fe603ee6041ed64172ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a75982ff4f3b5fe603ee6041ed64172ce">operator=</a> (const <a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;rhs)</td></tr>
<tr class="memdesc:a75982ff4f3b5fe603ee6041ed64172ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign another query's state to this object.  <a href="#a75982ff4f3b5fe603ee6041ed64172ce">More...</a><br/></td></tr>
<tr class="separator:a75982ff4f3b5fe603ee6041ed64172ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2ff95a7cd013758cb1ad9984a7b74e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a9c2ff95a7cd013758cb1ad9984a7b74e">operator void *</a> () const </td></tr>
<tr class="memdesc:a9c2ff95a7cd013758cb1ad9984a7b74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether the object has experienced an error condition.  <a href="#a9c2ff95a7cd013758cb1ad9984a7b74e">More...</a><br/></td></tr>
<tr class="separator:a9c2ff95a7cd013758cb1ad9984a7b74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5e3d5604dbe48cda5d8d2e64d896f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#adc5e3d5604dbe48cda5d8d2e64d896f4">operator!</a> () const </td></tr>
<tr class="memdesc:adc5e3d5604dbe48cda5d8d2e64d896f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the query object is not in a bad state.  <a href="#adc5e3d5604dbe48cda5d8d2e64d896f4">More...</a><br/></td></tr>
<tr class="separator:adc5e3d5604dbe48cda5d8d2e64d896f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfc86346581917cb833ed55ccd4d5b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a5bfc86346581917cb833ed55ccd4d5b8">parse</a> ()</td></tr>
<tr class="memdesc:a5bfc86346581917cb833ed55ccd4d5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treat the contents of the query string as a template query.  <a href="#a5bfc86346581917cb833ed55ccd4d5b8">More...</a><br/></td></tr>
<tr class="separator:a5bfc86346581917cb833ed55ccd4d5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12740e420c1d61b1d9c2995459a3ce0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#af12740e420c1d61b1d9c2995459a3ce0">reset</a> ()</td></tr>
<tr class="memdesc:af12740e420c1d61b1d9c2995459a3ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the query object so that it can be reused.  <a href="#af12740e420c1d61b1d9c2995459a3ce0">More...</a><br/></td></tr>
<tr class="separator:af12740e420c1d61b1d9c2995459a3ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02c4ab2f46159d9d45bfd2bbe57e2b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#ab02c4ab2f46159d9d45bfd2bbe57e2b4">result_empty</a> ()</td></tr>
<tr class="memdesc:ab02c4ab2f46159d9d45bfd2bbe57e2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the most recent result set was empty.  <a href="#ab02c4ab2f46159d9d45bfd2bbe57e2b4">More...</a><br/></td></tr>
<tr class="separator:ab02c4ab2f46159d9d45bfd2bbe57e2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17036cdcf4dd7a747b1ba6ee664da048"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17036cdcf4dd7a747b1ba6ee664da048"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a17036cdcf4dd7a747b1ba6ee664da048">str</a> ()</td></tr>
<tr class="memdesc:a17036cdcf4dd7a747b1ba6ee664da048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get built query as a C++ string. <br/></td></tr>
<tr class="separator:a17036cdcf4dd7a747b1ba6ee664da048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa8d56bd3d8a1bd3b5403665dbf6c8e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a7fa8d56bd3d8a1bd3b5403665dbf6c8e">str</a> (const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;arg0)</td></tr>
<tr class="memdesc:a7fa8d56bd3d8a1bd3b5403665dbf6c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get built query as a C++ string with template query parameter substitution.  <a href="#a7fa8d56bd3d8a1bd3b5403665dbf6c8e">More...</a><br/></td></tr>
<tr class="separator:a7fa8d56bd3d8a1bd3b5403665dbf6c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93d201c91a7e0b9056e8cac33a38f7d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#ac93d201c91a7e0b9056e8cac33a38f7d">str</a> (<a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;p)</td></tr>
<tr class="memdesc:ac93d201c91a7e0b9056e8cac33a38f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get built query as a null-terminated C++ string.  <a href="#ac93d201c91a7e0b9056e8cac33a38f7d">More...</a><br/></td></tr>
<tr class="separator:ac93d201c91a7e0b9056e8cac33a38f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23057cc385f9645d7d7ef00aecc2c8ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a23057cc385f9645d7d7ef00aecc2c8ba">exec</a> ()</td></tr>
<tr class="memdesc:a23057cc385f9645d7d7ef00aecc2c8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a built-up query.  <a href="#a23057cc385f9645d7d7ef00aecc2c8ba">More...</a><br/></td></tr>
<tr class="separator:a23057cc385f9645d7d7ef00aecc2c8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985acb52d0a988d1800c8fc4f4c5dc06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a985acb52d0a988d1800c8fc4f4c5dc06">exec</a> (const std::string &amp;<a class="el" href="classmysqlpp_1_1Query.html#a17036cdcf4dd7a747b1ba6ee664da048">str</a>)</td></tr>
<tr class="memdesc:a985acb52d0a988d1800c8fc4f4c5dc06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a query.  <a href="#a985acb52d0a988d1800c8fc4f4c5dc06">More...</a><br/></td></tr>
<tr class="separator:a985acb52d0a988d1800c8fc4f4c5dc06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ee1b9e393d88de946f5be804ea88cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1SimpleResult.html">SimpleResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a03ee1b9e393d88de946f5be804ea88cf">execute</a> ()</td></tr>
<tr class="memdesc:a03ee1b9e393d88de946f5be804ea88cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute built-up query.  <a href="#a03ee1b9e393d88de946f5be804ea88cf">More...</a><br/></td></tr>
<tr class="separator:a03ee1b9e393d88de946f5be804ea88cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf36ce2e47a62fae2cc507a7750d1ecd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1SimpleResult.html">SimpleResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#aaf36ce2e47a62fae2cc507a7750d1ecd">execute</a> (<a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;p)</td></tr>
<tr class="memdesc:aaf36ce2e47a62fae2cc507a7750d1ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute template query using given parameters.  <a href="#aaf36ce2e47a62fae2cc507a7750d1ecd">More...</a><br/></td></tr>
<tr class="separator:aaf36ce2e47a62fae2cc507a7750d1ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cc737d916e4e1c9fd0392316e5415c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1SimpleResult.html">SimpleResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#af2cc737d916e4e1c9fd0392316e5415c">execute</a> (const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;<a class="el" href="classmysqlpp_1_1Query.html#a17036cdcf4dd7a747b1ba6ee664da048">str</a>)</td></tr>
<tr class="memdesc:af2cc737d916e4e1c9fd0392316e5415c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a query that returns no rows.  <a href="#af2cc737d916e4e1c9fd0392316e5415c">More...</a><br/></td></tr>
<tr class="separator:af2cc737d916e4e1c9fd0392316e5415c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1faab5676c797dac619c6c98dc264e3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1SimpleResult.html">SimpleResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a1faab5676c797dac619c6c98dc264e3c">execute</a> (const char *<a class="el" href="classmysqlpp_1_1Query.html#a17036cdcf4dd7a747b1ba6ee664da048">str</a>, size_t len)</td></tr>
<tr class="memdesc:a1faab5676c797dac619c6c98dc264e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute query in a known-length string of characters. This can include null characters.  <a href="#a1faab5676c797dac619c6c98dc264e3c">More...</a><br/></td></tr>
<tr class="separator:a1faab5676c797dac619c6c98dc264e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8538e92f55a5536bbf7704d27151ed87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1UseQueryResult.html">UseQueryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a8538e92f55a5536bbf7704d27151ed87">use</a> ()</td></tr>
<tr class="memdesc:a8538e92f55a5536bbf7704d27151ed87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a query that can return rows, with access to the rows in sequence.  <a href="#a8538e92f55a5536bbf7704d27151ed87">More...</a><br/></td></tr>
<tr class="separator:a8538e92f55a5536bbf7704d27151ed87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66040c8c0071b50b043e8031309f7852"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1UseQueryResult.html">UseQueryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a66040c8c0071b50b043e8031309f7852">use</a> (<a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;p)</td></tr>
<tr class="memdesc:a66040c8c0071b50b043e8031309f7852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a template query that can return rows, with access to the rows in sequence.  <a href="#a66040c8c0071b50b043e8031309f7852">More...</a><br/></td></tr>
<tr class="separator:a66040c8c0071b50b043e8031309f7852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe90361bc4f17f78c11857d32538dabe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1UseQueryResult.html">UseQueryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#afe90361bc4f17f78c11857d32538dabe">use</a> (const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;<a class="el" href="classmysqlpp_1_1Query.html#a17036cdcf4dd7a747b1ba6ee664da048">str</a>)</td></tr>
<tr class="memdesc:afe90361bc4f17f78c11857d32538dabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a query that can return rows, with access to the rows in sequence.  <a href="#afe90361bc4f17f78c11857d32538dabe">More...</a><br/></td></tr>
<tr class="separator:afe90361bc4f17f78c11857d32538dabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00af2e285dbb32eb51de17e567d8b00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1UseQueryResult.html">UseQueryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#ab00af2e285dbb32eb51de17e567d8b00">use</a> (const char *<a class="el" href="classmysqlpp_1_1Query.html#a17036cdcf4dd7a747b1ba6ee664da048">str</a>, size_t len)</td></tr>
<tr class="memdesc:ab00af2e285dbb32eb51de17e567d8b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a query that can return rows, with access to the rows in sequence.  <a href="#ab00af2e285dbb32eb51de17e567d8b00">More...</a><br/></td></tr>
<tr class="separator:ab00af2e285dbb32eb51de17e567d8b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c800e645429d558f4295065b1aed73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1StoreQueryResult.html">StoreQueryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a16c800e645429d558f4295065b1aed73">store</a> ()</td></tr>
<tr class="memdesc:a16c800e645429d558f4295065b1aed73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a query that can return a result set.  <a href="#a16c800e645429d558f4295065b1aed73">More...</a><br/></td></tr>
<tr class="separator:a16c800e645429d558f4295065b1aed73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcd3c940f936f38bd40396449007d80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1StoreQueryResult.html">StoreQueryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a2bcd3c940f936f38bd40396449007d80">store</a> (<a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;p)</td></tr>
<tr class="memdesc:a2bcd3c940f936f38bd40396449007d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store results from a template query using given parameters.  <a href="#a2bcd3c940f936f38bd40396449007d80">More...</a><br/></td></tr>
<tr class="separator:a2bcd3c940f936f38bd40396449007d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4531cbffbb15c003ff35c3bbbd3b4397"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1StoreQueryResult.html">StoreQueryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a4531cbffbb15c003ff35c3bbbd3b4397">store</a> (const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;<a class="el" href="classmysqlpp_1_1Query.html#a17036cdcf4dd7a747b1ba6ee664da048">str</a>)</td></tr>
<tr class="memdesc:a4531cbffbb15c003ff35c3bbbd3b4397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a query that can return rows, returning all of the rows in a random-access container.  <a href="#a4531cbffbb15c003ff35c3bbbd3b4397">More...</a><br/></td></tr>
<tr class="separator:a4531cbffbb15c003ff35c3bbbd3b4397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f991f68505f9a35aed0a03932a1900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1StoreQueryResult.html">StoreQueryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a15f991f68505f9a35aed0a03932a1900">store</a> (const char *<a class="el" href="classmysqlpp_1_1Query.html#a17036cdcf4dd7a747b1ba6ee664da048">str</a>, size_t len)</td></tr>
<tr class="memdesc:a15f991f68505f9a35aed0a03932a1900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a query that can return rows, returning all of the rows in a random-access container.  <a href="#a15f991f68505f9a35aed0a03932a1900">More...</a><br/></td></tr>
<tr class="separator:a15f991f68505f9a35aed0a03932a1900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2468c96fcf7ea01ebde250f9e9cd0523"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:a2468c96fcf7ea01ebde250f9e9cd0523"><td class="memTemplItemLeft" align="right" valign="top">Function&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a2468c96fcf7ea01ebde250f9e9cd0523">for_each</a> (const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;query, Function fn)</td></tr>
<tr class="memdesc:a2468c96fcf7ea01ebde250f9e9cd0523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a query, and call a functor for each returned row.  <a href="#a2468c96fcf7ea01ebde250f9e9cd0523">More...</a><br/></td></tr>
<tr class="separator:a2468c96fcf7ea01ebde250f9e9cd0523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1436c089b356ccaeca67d1fd5bbd4280"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:a1436c089b356ccaeca67d1fd5bbd4280"><td class="memTemplItemLeft" align="right" valign="top">Function&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a1436c089b356ccaeca67d1fd5bbd4280">for_each</a> (Function fn)</td></tr>
<tr class="memdesc:a1436c089b356ccaeca67d1fd5bbd4280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the query, and call a functor for each returned row.  <a href="#a1436c089b356ccaeca67d1fd5bbd4280">More...</a><br/></td></tr>
<tr class="separator:a1436c089b356ccaeca67d1fd5bbd4280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e16f754112ec2f743db10d92059f86"><td class="memTemplParams" colspan="2">template&lt;class SSQLS , typename Function &gt; </td></tr>
<tr class="memitem:ab9e16f754112ec2f743db10d92059f86"><td class="memTemplItemLeft" align="right" valign="top">Function&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#ab9e16f754112ec2f743db10d92059f86">for_each</a> (const SSQLS &amp;ssqls, Function fn)</td></tr>
<tr class="memdesc:ab9e16f754112ec2f743db10d92059f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a functor for every row in a table.  <a href="#ab9e16f754112ec2f743db10d92059f86">More...</a><br/></td></tr>
<tr class="separator:ab9e16f754112ec2f743db10d92059f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c3181bf3e2bc4399a302a60c4a3527"><td class="memTemplParams" colspan="2">template&lt;class Sequence , typename Function &gt; </td></tr>
<tr class="memitem:ad7c3181bf3e2bc4399a302a60c4a3527"><td class="memTemplItemLeft" align="right" valign="top">Function&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#ad7c3181bf3e2bc4399a302a60c4a3527">store_if</a> (Sequence &amp;con, const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;query, Function fn)</td></tr>
<tr class="memdesc:ad7c3181bf3e2bc4399a302a60c4a3527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a query, conditionally storing each row in a container.  <a href="#ad7c3181bf3e2bc4399a302a60c4a3527">More...</a><br/></td></tr>
<tr class="separator:ad7c3181bf3e2bc4399a302a60c4a3527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a044520c6a19e55ad0fbfa4b52ae237"><td class="memTemplParams" colspan="2">template&lt;class Sequence , class SSQLS , typename Function &gt; </td></tr>
<tr class="memitem:a7a044520c6a19e55ad0fbfa4b52ae237"><td class="memTemplItemLeft" align="right" valign="top">Function&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a7a044520c6a19e55ad0fbfa4b52ae237">store_if</a> (Sequence &amp;con, const SSQLS &amp;ssqls, Function fn)</td></tr>
<tr class="memdesc:a7a044520c6a19e55ad0fbfa4b52ae237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pulls every row in a table, conditionally storing each one in a container.  <a href="#a7a044520c6a19e55ad0fbfa4b52ae237">More...</a><br/></td></tr>
<tr class="separator:a7a044520c6a19e55ad0fbfa4b52ae237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6e8dcd8e1538017c11ac02b2846ce2"><td class="memTemplParams" colspan="2">template&lt;class Sequence , typename Function &gt; </td></tr>
<tr class="memitem:a6d6e8dcd8e1538017c11ac02b2846ce2"><td class="memTemplItemLeft" align="right" valign="top">Function&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a6d6e8dcd8e1538017c11ac02b2846ce2">store_if</a> (Sequence &amp;con, Function fn)</td></tr>
<tr class="memdesc:a6d6e8dcd8e1538017c11ac02b2846ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the query, conditionally storing each row in a container.  <a href="#a6d6e8dcd8e1538017c11ac02b2846ce2">More...</a><br/></td></tr>
<tr class="separator:a6d6e8dcd8e1538017c11ac02b2846ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e22c60aa550675b5e89ab9bbaea7f8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1StoreQueryResult.html">StoreQueryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a0e22c60aa550675b5e89ab9bbaea7f8e">store_next</a> ()</td></tr>
<tr class="memdesc:a0e22c60aa550675b5e89ab9bbaea7f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return next result set, when processing a multi-query.  <a href="#a0e22c60aa550675b5e89ab9bbaea7f8e">More...</a><br/></td></tr>
<tr class="separator:a0e22c60aa550675b5e89ab9bbaea7f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeaff6b3fb94ff4bcad4046a833ee2ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#aeeaff6b3fb94ff4bcad4046a833ee2ed">more_results</a> ()</td></tr>
<tr class="memdesc:aeeaff6b3fb94ff4bcad4046a833ee2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether more results are waiting for a multi-query or stored procedure response.  <a href="#aeeaff6b3fb94ff4bcad4046a833ee2ed">More...</a><br/></td></tr>
<tr class="separator:aeeaff6b3fb94ff4bcad4046a833ee2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948387c9f15db2837e7aad557c955424"><td class="memTemplParams" colspan="2">template&lt;class Sequence &gt; </td></tr>
<tr class="memitem:a948387c9f15db2837e7aad557c955424"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a948387c9f15db2837e7aad557c955424">storein_sequence</a> (Sequence &amp;con)</td></tr>
<tr class="memdesc:a948387c9f15db2837e7aad557c955424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a query, storing the result set in an STL sequence container.  <a href="#a948387c9f15db2837e7aad557c955424">More...</a><br/></td></tr>
<tr class="separator:a948387c9f15db2837e7aad557c955424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa1ef7235bee641ae4a42a4944fa69c"><td class="memTemplParams" colspan="2">template&lt;class Sequence &gt; </td></tr>
<tr class="memitem:a2fa1ef7235bee641ae4a42a4944fa69c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a2fa1ef7235bee641ae4a42a4944fa69c">storein_sequence</a> (Sequence &amp;con, const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;s)</td></tr>
<tr class="memdesc:a2fa1ef7235bee641ae4a42a4944fa69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a query, storing the result rows in an STL sequence container.  <a href="#a2fa1ef7235bee641ae4a42a4944fa69c">More...</a><br/></td></tr>
<tr class="separator:a2fa1ef7235bee641ae4a42a4944fa69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b378e41e2de26cb0f16ca004c116760"><td class="memTemplParams" colspan="2">template&lt;class Seq &gt; </td></tr>
<tr class="memitem:a1b378e41e2de26cb0f16ca004c116760"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a1b378e41e2de26cb0f16ca004c116760">storein_sequence</a> (Seq &amp;con, <a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;p)</td></tr>
<tr class="memdesc:a1b378e41e2de26cb0f16ca004c116760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute template query using given parameters, storing the results in a sequence type container.  <a href="#a1b378e41e2de26cb0f16ca004c116760">More...</a><br/></td></tr>
<tr class="separator:a1b378e41e2de26cb0f16ca004c116760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7fb34235a244fd3d92e62fc026946f"><td class="memTemplParams" colspan="2">template&lt;class Set &gt; </td></tr>
<tr class="memitem:aef7fb34235a244fd3d92e62fc026946f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#aef7fb34235a244fd3d92e62fc026946f">storein_set</a> (<a class="el" href="classmysqlpp_1_1Set.html">Set</a> &amp;con)</td></tr>
<tr class="memdesc:aef7fb34235a244fd3d92e62fc026946f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a query, storing the result set in an STL associative container.  <a href="#aef7fb34235a244fd3d92e62fc026946f">More...</a><br/></td></tr>
<tr class="separator:aef7fb34235a244fd3d92e62fc026946f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82a6e6f875c8d1834ac4e56979969bc"><td class="memTemplParams" colspan="2">template&lt;class Set &gt; </td></tr>
<tr class="memitem:af82a6e6f875c8d1834ac4e56979969bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#af82a6e6f875c8d1834ac4e56979969bc">storein_set</a> (<a class="el" href="classmysqlpp_1_1Set.html">Set</a> &amp;con, const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;s)</td></tr>
<tr class="memdesc:af82a6e6f875c8d1834ac4e56979969bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a query, storing the result rows in an STL set-associative container.  <a href="#af82a6e6f875c8d1834ac4e56979969bc">More...</a><br/></td></tr>
<tr class="separator:af82a6e6f875c8d1834ac4e56979969bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af207b0559f75833bbf38e670dc217978"><td class="memTemplParams" colspan="2">template&lt;class Set &gt; </td></tr>
<tr class="memitem:af207b0559f75833bbf38e670dc217978"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#af207b0559f75833bbf38e670dc217978">storein_set</a> (<a class="el" href="classmysqlpp_1_1Set.html">Set</a> &amp;con, <a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;p)</td></tr>
<tr class="memdesc:af207b0559f75833bbf38e670dc217978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute template query using given parameters, storing the results in a set type container.  <a href="#af207b0559f75833bbf38e670dc217978">More...</a><br/></td></tr>
<tr class="separator:af207b0559f75833bbf38e670dc217978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba080b7a2f2cd4086fbb374ae86b6e9"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a8ba080b7a2f2cd4086fbb374ae86b6e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a8ba080b7a2f2cd4086fbb374ae86b6e9">storein</a> (Container &amp;con)</td></tr>
<tr class="memdesc:a8ba080b7a2f2cd4086fbb374ae86b6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a query, and store the entire result set in an STL container.  <a href="#a8ba080b7a2f2cd4086fbb374ae86b6e9">More...</a><br/></td></tr>
<tr class="separator:a8ba080b7a2f2cd4086fbb374ae86b6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461d17d9db64dd040339cbff070ea02c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a461d17d9db64dd040339cbff070ea02c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a461d17d9db64dd040339cbff070ea02c">storein</a> (T &amp;con, <a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;p)</td></tr>
<tr class="memdesc:a461d17d9db64dd040339cbff070ea02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store template query results into a container.  <a href="#a461d17d9db64dd040339cbff070ea02c">More...</a><br/></td></tr>
<tr class="separator:a461d17d9db64dd040339cbff070ea02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47fd3e16132af6238b6c6a182fb18f4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae47fd3e16132af6238b6c6a182fb18f4"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae47fd3e16132af6238b6c6a182fb18f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#ae47fd3e16132af6238b6c6a182fb18f4">storein</a> (std::vector&lt; T &gt; &amp;con, const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;s)</td></tr>
<tr class="memdesc:ae47fd3e16132af6238b6c6a182fb18f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classmysqlpp_1_1Query.html#a948387c9f15db2837e7aad557c955424" title="Execute a query, storing the result set in an STL sequence container. ">storein_sequence()</a> for <code>std::vector</code>. <br/></td></tr>
<tr class="separator:ae47fd3e16132af6238b6c6a182fb18f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04245f7ef8e01ebbe162674c3daaea73"><td class="memTemplParams" colspan="2"><a class="anchor" id="a04245f7ef8e01ebbe162674c3daaea73"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a04245f7ef8e01ebbe162674c3daaea73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a04245f7ef8e01ebbe162674c3daaea73">storein</a> (std::deque&lt; T &gt; &amp;con, const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;s)</td></tr>
<tr class="memdesc:a04245f7ef8e01ebbe162674c3daaea73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classmysqlpp_1_1Query.html#a948387c9f15db2837e7aad557c955424" title="Execute a query, storing the result set in an STL sequence container. ">storein_sequence()</a> for <code>std::deque</code>. <br/></td></tr>
<tr class="separator:a04245f7ef8e01ebbe162674c3daaea73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8407a8143474046bd147fbd5a322ec98"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8407a8143474046bd147fbd5a322ec98"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8407a8143474046bd147fbd5a322ec98"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a8407a8143474046bd147fbd5a322ec98">storein</a> (std::list&lt; T &gt; &amp;con, const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;s)</td></tr>
<tr class="memdesc:a8407a8143474046bd147fbd5a322ec98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classmysqlpp_1_1Query.html#a948387c9f15db2837e7aad557c955424" title="Execute a query, storing the result set in an STL sequence container. ">storein_sequence()</a> for <code>std::list</code>. <br/></td></tr>
<tr class="separator:a8407a8143474046bd147fbd5a322ec98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fbb8786321102e82bfa5fe681e763f"><td class="memTemplParams" colspan="2"><a class="anchor" id="af6fbb8786321102e82bfa5fe681e763f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af6fbb8786321102e82bfa5fe681e763f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#af6fbb8786321102e82bfa5fe681e763f">storein</a> (std::set&lt; T &gt; &amp;con, const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;s)</td></tr>
<tr class="memdesc:af6fbb8786321102e82bfa5fe681e763f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classmysqlpp_1_1Query.html#aef7fb34235a244fd3d92e62fc026946f" title="Execute a query, storing the result set in an STL associative container. ">storein_set()</a> for <code>std::set</code>. <br/></td></tr>
<tr class="separator:af6fbb8786321102e82bfa5fe681e763f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98ff9a520fe140f7622994c951b6dff"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab98ff9a520fe140f7622994c951b6dff"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab98ff9a520fe140f7622994c951b6dff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#ab98ff9a520fe140f7622994c951b6dff">storein</a> (std::multiset&lt; T &gt; &amp;con, const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;s)</td></tr>
<tr class="memdesc:ab98ff9a520fe140f7622994c951b6dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classmysqlpp_1_1Query.html#aef7fb34235a244fd3d92e62fc026946f" title="Execute a query, storing the result set in an STL associative container. ">storein_set()</a> for <code>std::multiset</code>. <br/></td></tr>
<tr class="separator:ab98ff9a520fe140f7622994c951b6dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64aa3f8489020795552965c70b515428"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a64aa3f8489020795552965c70b515428"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a64aa3f8489020795552965c70b515428">update</a> (const T &amp;o, const T &amp;n)</td></tr>
<tr class="memdesc:a64aa3f8489020795552965c70b515428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace an existing row's data with new data.  <a href="#a64aa3f8489020795552965c70b515428">More...</a><br/></td></tr>
<tr class="separator:a64aa3f8489020795552965c70b515428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91bbb80705fce681f30f32c6df4c0c2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa91bbb80705fce681f30f32c6df4c0c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#aa91bbb80705fce681f30f32c6df4c0c2">insert</a> (const T &amp;v)</td></tr>
<tr class="memdesc:aa91bbb80705fce681f30f32c6df4c0c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new row.  <a href="#aa91bbb80705fce681f30f32c6df4c0c2">More...</a><br/></td></tr>
<tr class="separator:aa91bbb80705fce681f30f32c6df4c0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b148136e317f91aee3a43b3d7b2250"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a27b148136e317f91aee3a43b3d7b2250"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a27b148136e317f91aee3a43b3d7b2250">insert</a> (Iter first, Iter last)</td></tr>
<tr class="memdesc:a27b148136e317f91aee3a43b3d7b2250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert multiple new rows.  <a href="#a27b148136e317f91aee3a43b3d7b2250">More...</a><br/></td></tr>
<tr class="separator:a27b148136e317f91aee3a43b3d7b2250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9084d8e752601d5663ab145be02ef224"><td class="memTemplParams" colspan="2">template&lt;class Iter , class InsertPolicy &gt; </td></tr>
<tr class="memitem:a9084d8e752601d5663ab145be02ef224"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a9084d8e752601d5663ab145be02ef224">insertfrom</a> (Iter first, Iter last, InsertPolicy &amp;policy)</td></tr>
<tr class="memdesc:a9084d8e752601d5663ab145be02ef224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert multiple new rows using an insert policy to control how the INSERT statements are created using items from an STL container.  <a href="#a9084d8e752601d5663ab145be02ef224">More...</a><br/></td></tr>
<tr class="separator:a9084d8e752601d5663ab145be02ef224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff065d1b18f3c6141ef57ce9d542837"><td class="memTemplParams" colspan="2">template&lt;class Iter , class InsertPolicy &gt; </td></tr>
<tr class="memitem:a7ff065d1b18f3c6141ef57ce9d542837"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a7ff065d1b18f3c6141ef57ce9d542837">replacefrom</a> (Iter first, Iter last, InsertPolicy &amp;policy)</td></tr>
<tr class="memdesc:a7ff065d1b18f3c6141ef57ce9d542837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace multiple new rows using an insert policy to control how the REPLACE statements are created using items from an STL container.  <a href="#a7ff065d1b18f3c6141ef57ce9d542837">More...</a><br/></td></tr>
<tr class="separator:a7ff065d1b18f3c6141ef57ce9d542837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d5b5aa23b96c600c157718e4ac60b4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa2d5b5aa23b96c600c157718e4ac60b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#aa2d5b5aa23b96c600c157718e4ac60b4">replace</a> (const T &amp;v)</td></tr>
<tr class="memdesc:aa2d5b5aa23b96c600c157718e4ac60b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new row unless there is an existing row that matches on a unique index, in which case we replace it.  <a href="#aa2d5b5aa23b96c600c157718e4ac60b4">More...</a><br/></td></tr>
<tr class="separator:aa2d5b5aa23b96c600c157718e4ac60b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4359a9dbd99e93ded73d5df5cd244ba"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:ab4359a9dbd99e93ded73d5df5cd244ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#ab4359a9dbd99e93ded73d5df5cd244ba">replace</a> (Iter first, Iter last)</td></tr>
<tr class="memdesc:ab4359a9dbd99e93ded73d5df5cd244ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert multiple new rows, or replace existing ones if there are existing rows that match on key fields.  <a href="#ab4359a9dbd99e93ded73d5df5cd244ba">More...</a><br/></td></tr>
<tr class="separator:ab4359a9dbd99e93ded73d5df5cd244ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmysqlpp_1_1OptionalExceptions"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmysqlpp_1_1OptionalExceptions')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmysqlpp_1_1OptionalExceptions.html">mysqlpp::OptionalExceptions</a></td></tr>
<tr class="memitem:a45a3e93f56716abf10704419b5ba4f31 inherit pub_methods_classmysqlpp_1_1OptionalExceptions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1OptionalExceptions.html#a45a3e93f56716abf10704419b5ba4f31">OptionalExceptions</a> (bool e=true)</td></tr>
<tr class="memdesc:a45a3e93f56716abf10704419b5ba4f31 inherit pub_methods_classmysqlpp_1_1OptionalExceptions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a45a3e93f56716abf10704419b5ba4f31">More...</a><br/></td></tr>
<tr class="separator:a45a3e93f56716abf10704419b5ba4f31 inherit pub_methods_classmysqlpp_1_1OptionalExceptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97334b7e5f89c1927c5d277b770db0a inherit pub_methods_classmysqlpp_1_1OptionalExceptions"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae97334b7e5f89c1927c5d277b770db0a"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1OptionalExceptions.html#ae97334b7e5f89c1927c5d277b770db0a">~OptionalExceptions</a> ()</td></tr>
<tr class="memdesc:ae97334b7e5f89c1927c5d277b770db0a inherit pub_methods_classmysqlpp_1_1OptionalExceptions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy object. <br/></td></tr>
<tr class="separator:ae97334b7e5f89c1927c5d277b770db0a inherit pub_methods_classmysqlpp_1_1OptionalExceptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada38946e3352da3fa90ba57e9b6a9c18 inherit pub_methods_classmysqlpp_1_1OptionalExceptions"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada38946e3352da3fa90ba57e9b6a9c18"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1OptionalExceptions.html#ada38946e3352da3fa90ba57e9b6a9c18">enable_exceptions</a> () const </td></tr>
<tr class="memdesc:ada38946e3352da3fa90ba57e9b6a9c18 inherit pub_methods_classmysqlpp_1_1OptionalExceptions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable exceptions from the object. <br/></td></tr>
<tr class="separator:ada38946e3352da3fa90ba57e9b6a9c18 inherit pub_methods_classmysqlpp_1_1OptionalExceptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c18f4a1da49f55652fbd8840cd67d82 inherit pub_methods_classmysqlpp_1_1OptionalExceptions"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c18f4a1da49f55652fbd8840cd67d82"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1OptionalExceptions.html#a5c18f4a1da49f55652fbd8840cd67d82">disable_exceptions</a> () const </td></tr>
<tr class="memdesc:a5c18f4a1da49f55652fbd8840cd67d82 inherit pub_methods_classmysqlpp_1_1OptionalExceptions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable exceptions from the object. <br/></td></tr>
<tr class="separator:a5c18f4a1da49f55652fbd8840cd67d82 inherit pub_methods_classmysqlpp_1_1OptionalExceptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6231a5e3fd15fd5ecc4c74785b8c4514 inherit pub_methods_classmysqlpp_1_1OptionalExceptions"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6231a5e3fd15fd5ecc4c74785b8c4514"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1OptionalExceptions.html#a6231a5e3fd15fd5ecc4c74785b8c4514">throw_exceptions</a> () const </td></tr>
<tr class="memdesc:a6231a5e3fd15fd5ecc4c74785b8c4514 inherit pub_methods_classmysqlpp_1_1OptionalExceptions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if exceptions are enabled. <br/></td></tr>
<tr class="separator:a6231a5e3fd15fd5ecc4c74785b8c4514 inherit pub_methods_classmysqlpp_1_1OptionalExceptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a622a5b10c49ab798f7f5481ff38a55d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a622a5b10c49ab798f7f5481ff38a55d1">template_defaults</a></td></tr>
<tr class="memdesc:a622a5b10c49ab798f7f5481ff38a55d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default template parameters.  <a href="#a622a5b10c49ab798f7f5481ff38a55d1">More...</a><br/></td></tr>
<tr class="separator:a622a5b10c49ab798f7f5481ff38a55d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:accfe0b3b7df94fac0b2d30da93b72ed5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accfe0b3b7df94fac0b2d30da93b72ed5"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SQLQueryParms</b></td></tr>
<tr class="separator:accfe0b3b7df94fac0b2d30da93b72ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classmysqlpp_1_1OptionalExceptions"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmysqlpp_1_1OptionalExceptions')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmysqlpp_1_1OptionalExceptions.html">mysqlpp::OptionalExceptions</a></td></tr>
<tr class="memitem:a0273012228b9e6889908a6a93aa47973 inherit pro_methods_classmysqlpp_1_1OptionalExceptions"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1OptionalExceptions.html#a0273012228b9e6889908a6a93aa47973">set_exceptions</a> (bool e) const </td></tr>
<tr class="memdesc:a0273012228b9e6889908a6a93aa47973 inherit pro_methods_classmysqlpp_1_1OptionalExceptions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the exception state to a particular value.  <a href="#a0273012228b9e6889908a6a93aa47973">More...</a><br/></td></tr>
<tr class="separator:a0273012228b9e6889908a6a93aa47973 inherit pro_methods_classmysqlpp_1_1OptionalExceptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class for building and executing SQL queries. </p>
<p>One does not generally create <a class="el" href="classmysqlpp_1_1Query.html" title="A class for building and executing SQL queries. ">Query</a> objects directly. Instead, call <a class="el" href="classmysqlpp_1_1Connection.html#a6954d437d52004915fbc96a0be79ab37" title="Return a new query object. ">mysqlpp::Connection::query()</a> to get one tied to that connection.</p>
<p>There are several ways to build and execute SQL queries with this class.</p>
<p>The way most like other database libraries is to pass a SQL statement in either the form of a C or C++ string to one of the <a class="el" href="classmysqlpp_1_1Query.html#a03ee1b9e393d88de946f5be804ea88cf">exec*(), </a> <a class="el" href="classmysqlpp_1_1Query.html#a16c800e645429d558f4295065b1aed73">store*(), </a> or <a class="el" href="classmysqlpp_1_1Query.html#a8538e92f55a5536bbf7704d27151ed87" title="Execute a query that can return rows, with access to the rows in sequence. ">use()</a> methods. The query is executed immediately, and any results returned.</p>
<p>For more complicated queries, it's often more convenient to build up the query string over several C++ statements using <a class="el" href="classmysqlpp_1_1Query.html" title="A class for building and executing SQL queries. ">Query</a>'s stream interface. It works like any other C++ stream (<code>std::cout</code>, <code>std::ostringstream</code>, etc.) in that you can just insert things into the stream, building the query up piece by piece. When the query string is complete, you call the overloaded version of <a class="el" href="classmysqlpp_1_1Query.html#a03ee1b9e393d88de946f5be804ea88cf">exec*(), </a> <a class="el" href="classmysqlpp_1_1Query.html#a16c800e645429d558f4295065b1aed73">store*(), </a> or <a class="el" href="classmysqlpp_1_1Query.html#a8538e92f55a5536bbf7704d27151ed87">use() </a> takes no parameters, which executes the built query and returns any results.</p>
<p>If you are using the library's Specialized SQL Structures feature, <a class="el" href="classmysqlpp_1_1Query.html" title="A class for building and executing SQL queries. ">Query</a> has several special functions for generating common SQL queries from those structures. For instance, it offers the <a class="el" href="classmysqlpp_1_1Query.html#aa91bbb80705fce681f30f32c6df4c0c2">insert() </a> method, which builds an INSERT query to add the contents of the SSQLS to the database. As with the stream interface, these methods only build the query string; call one of the parameterless methods mentioned previously to actually execute the query.</p>
<p>Finally, you can build "template queries". This is something like C's <code>printf()</code> function, in that you insert a specially-formatted query string into the object which contains placeholders for data. You call the <a class="el" href="classmysqlpp_1_1Query.html#a5bfc86346581917cb833ed55ccd4d5b8" title="Treat the contents of the query string as a template query. ">parse()</a> method to tell the <a class="el" href="classmysqlpp_1_1Query.html" title="A class for building and executing SQL queries. ">Query</a> object that the query string contains placeholders. Having done that, you call one of the the many <a class="el" href="classmysqlpp_1_1Query.html#af2cc737d916e4e1c9fd0392316e5415c">exec*(), </a> <a class="el" href="classmysqlpp_1_1Query.html#a4531cbffbb15c003ff35c3bbbd3b4397">store*(), </a> or <a class="el" href="classmysqlpp_1_1Query.html#afe90361bc4f17f78c11857d32538dabe">use() </a> overloads that take <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html" title="Converts many different data types to strings suitable for use in SQL queries. ">SQLTypeAdapter</a> objects. There are 25 of each by default, differing only in the number of STA objects they take. (See <code>lib/querydef.pl</code> if you need to change the limit, or <code>examples/tquery2.cpp</code> for a way around it that doesn't require changing the library.) Only the version taking a single STA object is documented below, as to document all of them would just be repetitive. For each <a class="el" href="classmysqlpp_1_1Query.html" title="A class for building and executing SQL queries. ">Query</a> method that takes a single STA object, there's a good chance there's a set of undocumented overloads that take more of them for the purpose of filling out a template query.</p>
<p>See the user manual for more details about these options. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6c6cbae18ebcb31b6d44e7784d5a3daa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::Query::Query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>te</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>qstr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new query object attached to a connection. </p>
<p>This is the constructor used by <a class="el" href="classmysqlpp_1_1Connection.html#a6954d437d52004915fbc96a0be79ab37" title="Return a new query object. ">mysqlpp::Connection::query()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>connection the finished query should be sent out on </td></tr>
    <tr><td class="paramname">te</td><td>if true, throw exceptions on errors </td></tr>
    <tr><td class="paramname">qstr</td><td>an optional initial query string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a936b1062bb31b3428ead059a26590b6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::Query::Query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new query object as a copy of another. </p>
<p>This is <b>not</b> a traditional copy ctor! Its only purpose is to make it possible to assign the return of <a class="el" href="classmysqlpp_1_1Connection.html#a6954d437d52004915fbc96a0be79ab37" title="Return a new query object. ">Connection::query()</a> to an empty <a class="el" href="classmysqlpp_1_1Query.html" title="A class for building and executing SQL queries. ">Query</a> object. In particular, the stream buffer and template query stuff will be empty in the copy, regardless of what values they have in the original. </p>

<p>References <a class="el" href="classmysqlpp_1_1Query.html#a75982ff4f3b5fe603ee6041ed64172ce">operator=()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3acf442e091bdfb5344cbe9990f05f3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mysqlpp::Query::errnum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the last error number that was set. </p>
<p>This just delegates to <a class="el" href="classmysqlpp_1_1Connection.html#a3cb1bf601b19dbb87b36bed4590f4214" title="Return last error number associated with this connection. ">Connection::errnum()</a>. <a class="el" href="classmysqlpp_1_1Query.html" title="A class for building and executing SQL queries. ">Query</a> has nothing extra to say, so use either, as makes sense in your program. </p>

<p>References <a class="el" href="classmysqlpp_1_1Connection.html#a3cb1bf601b19dbb87b36bed4590f4214">mysqlpp::Connection::errnum()</a>.</p>

<p>Referenced by <a class="el" href="classmysqlpp_1_1Query.html#a985acb52d0a988d1800c8fc4f4c5dc06">exec()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a1faab5676c797dac619c6c98dc264e3c">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a15f991f68505f9a35aed0a03932a1900">store()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a0e22c60aa550675b5e89ab9bbaea7f8e">store_next()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#ab00af2e285dbb32eb51de17e567d8b00">use()</a>.</p>

</div>
</div>
<a class="anchor" id="a24ddaff8ae037c56c1a5aceda34e89c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * mysqlpp::Query::error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the last error message that was set. </p>
<p>This just delegates to <a class="el" href="classmysqlpp_1_1Connection.html#a73c67c9a4d4c77fcf2c7a98555542c8a" title="Return error message for last error associated with this connection. ">Connection::error()</a>. <a class="el" href="classmysqlpp_1_1Query.html" title="A class for building and executing SQL queries. ">Query</a> has nothing extra to say, so use either, as makes sense in your program. </p>

<p>References <a class="el" href="classmysqlpp_1_1Connection.html#a73c67c9a4d4c77fcf2c7a98555542c8a">mysqlpp::Connection::error()</a>.</p>

<p>Referenced by <a class="el" href="classmysqlpp_1_1Query.html#a985acb52d0a988d1800c8fc4f4c5dc06">exec()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a1faab5676c797dac619c6c98dc264e3c">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a15f991f68505f9a35aed0a03932a1900">store()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a0e22c60aa550675b5e89ab9bbaea7f8e">store_next()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#ab00af2e285dbb32eb51de17e567d8b00">use()</a>.</p>

</div>
</div>
<a class="anchor" id="adc7d259cbf78f1e418b7ad12751c5342"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mysqlpp::Query::escape_string </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>ps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>original</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a SQL-escaped version of a character buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>pointer to C++ string to hold escaped version; if original is 0, also holds the original data to be escaped </td></tr>
    <tr><td class="paramname">original</td><td>if given, pointer to the character buffer to escape instead of contents of *ps </td></tr>
    <tr><td class="paramname">length</td><td>if both this and original are given, number of characters to escape instead of ps-&gt;length()</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">number</td><td>of characters placed in *ps</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>comments for escape_string(char*, const char*, size_t) and <a class="el" href="classmysqlpp_1_1DBDriver.html#a64b30d25d02719ffc22f9b3ba92cdd89" title="Return a SQL-escaped version of a character buffer. ">DBDriver::escape_string(std::string*, const char *, size_t)</a> for further details. </dd></dl>

<p>References <a class="el" href="classmysqlpp_1_1Connection.html#a0d118df40a7bd4bb63e7286b221f7680">mysqlpp::Connection::driver()</a>, <a class="el" href="classmysqlpp_1_1DBDriver.html#a69881b0fab7f7d10c1d1adc7aacbbd6a">mysqlpp::DBDriver::escape_string()</a>, and <a class="el" href="classmysqlpp_1_1DBDriver.html#a2a404051fc2cc55b9e1f41cfe47190f3">mysqlpp::DBDriver::escape_string_no_conn()</a>.</p>

</div>
</div>
<a class="anchor" id="ab9061afbd8f1c03751b92b8ec6ba0de9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mysqlpp::Query::escape_string </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>escaped</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a SQL-escaped version of the given character buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">escaped</td><td>character buffer to hold escaped version; must point to at least (length * 2 + 1) bytes </td></tr>
    <tr><td class="paramname">original</td><td>pointer to the character buffer to escape </td></tr>
    <tr><td class="paramname">length</td><td>number of characters to escape</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">number</td><td>of characters placed in escaped</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classmysqlpp_1_1DBDriver.html" title="Provides a thin abstraction layer over the underlying database client library. ">DBDriver</a> provides two versions of this method and <a class="el" href="classmysqlpp_1_1Query.html#adc7d259cbf78f1e418b7ad12751c5342" title="Return a SQL-escaped version of a character buffer. ">Query::escape_string()</a> calls the appropriate one based on whether or not a database connection is available. If the connection is available, it can call the <a class="el" href="classmysqlpp_1_1DBDriver.html#a69881b0fab7f7d10c1d1adc7aacbbd6a" title="Return a SQL-escaped version of the given character buffer. ">DBDriver::escape_string()</a> method. If there is no database connection available (normally only in testing), then <a class="el" href="classmysqlpp_1_1DBDriver.html" title="Provides a thin abstraction layer over the underlying database client library. ">DBDriver</a> provides a static version of the function that doesn't use a database connection.</p>
<dl class="section see"><dt>See Also</dt><dd>comments for <a class="el" href="classmysqlpp_1_1DBDriver.html#a69881b0fab7f7d10c1d1adc7aacbbd6a" title="Return a SQL-escaped version of the given character buffer. ">DBDriver::escape_string(char*, const char*, size_t)</a>, <a class="el" href="classmysqlpp_1_1DBDriver.html#a2a404051fc2cc55b9e1f41cfe47190f3" title="SQL-escapes the given string without reference to the character set of a database server...">DBDriver::escape_string_no_conn(char*, const char*, size_t)</a> for further details. </dd></dl>

<p>References <a class="el" href="classmysqlpp_1_1Connection.html#a0d118df40a7bd4bb63e7286b221f7680">mysqlpp::Connection::driver()</a>, <a class="el" href="classmysqlpp_1_1DBDriver.html#a69881b0fab7f7d10c1d1adc7aacbbd6a">mysqlpp::DBDriver::escape_string()</a>, and <a class="el" href="classmysqlpp_1_1DBDriver.html#a2a404051fc2cc55b9e1f41cfe47190f3">mysqlpp::DBDriver::escape_string_no_conn()</a>.</p>

</div>
</div>
<a class="anchor" id="a23057cc385f9645d7d7ef00aecc2c8ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mysqlpp::Query::exec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a built-up query. </p>
<p>Same as <a class="el" href="classmysqlpp_1_1Query.html#a23057cc385f9645d7d7ef00aecc2c8ba" title="Execute a built-up query. ">exec()</a>, except that it uses the query string built up within the query object already instead of accepting a query string from the caller.</p>
<dl class="section return"><dt>Returns</dt><dd>true if query was executed successfully</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmysqlpp_1_1Query.html#a985acb52d0a988d1800c8fc4f4c5dc06" title="Execute a query. ">exec(const std::string&amp; str)</a>, <a class="el" href="classmysqlpp_1_1Query.html#a03ee1b9e393d88de946f5be804ea88cf" title="Execute built-up query. ">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a16c800e645429d558f4295065b1aed73" title="Execute a query that can return a result set. ">store()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a8ba080b7a2f2cd4086fbb374ae86b6e9" title="Execute a query, and store the entire result set in an STL container. ">storein()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a8538e92f55a5536bbf7704d27151ed87" title="Execute a query that can return rows, with access to the rows in sequence. ">use()</a> </dd></dl>

<p>References <a class="el" href="classmysqlpp_1_1Query.html#a23057cc385f9645d7d7ef00aecc2c8ba">exec()</a>.</p>

<p>Referenced by <a class="el" href="classmysqlpp_1_1Connection.html#ac9852fb87572c6f10c6de051bacf6b8d">mysqlpp::Connection::create_db()</a>, <a class="el" href="classmysqlpp_1_1Connection.html#aa073e784a16a9d4b357740a626a6b2e1">mysqlpp::Connection::drop_db()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a23057cc385f9645d7d7ef00aecc2c8ba">exec()</a>.</p>

</div>
</div>
<a class="anchor" id="a985acb52d0a988d1800c8fc4f4c5dc06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mysqlpp::Query::exec </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a query. </p>
<p>Same as <a class="el" href="classmysqlpp_1_1Query.html#a03ee1b9e393d88de946f5be804ea88cf" title="Execute built-up query. ">execute()</a>, except that it only returns a flag indicating whether the query succeeded or not. It is basically a thin wrapper around the C API function <code>mysql_real_query()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the query to execute</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if query was executed successfully</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmysqlpp_1_1Query.html#a03ee1b9e393d88de946f5be804ea88cf" title="Execute built-up query. ">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a16c800e645429d558f4295065b1aed73" title="Execute a query that can return a result set. ">store()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a8ba080b7a2f2cd4086fbb374ae86b6e9" title="Execute a query, and store the entire result set in an STL container. ">storein()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a8538e92f55a5536bbf7704d27151ed87" title="Execute a query that can return rows, with access to the rows in sequence. ">use()</a> </dd></dl>

<p>References <a class="el" href="classmysqlpp_1_1Connection.html#a0d118df40a7bd4bb63e7286b221f7680">mysqlpp::Connection::driver()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a3acf442e091bdfb5344cbe9990f05f3b">errnum()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a24ddaff8ae037c56c1a5aceda34e89c8">error()</a>, <a class="el" href="classmysqlpp_1_1DBDriver.html#aa5ce8af647f93839757a8398a9e106db">mysqlpp::DBDriver::execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#af12740e420c1d61b1d9c2995459a3ce0">reset()</a>, and <a class="el" href="classmysqlpp_1_1OptionalExceptions.html#a6231a5e3fd15fd5ecc4c74785b8c4514">mysqlpp::OptionalExceptions::throw_exceptions()</a>.</p>

</div>
</div>
<a class="anchor" id="a03ee1b9e393d88de946f5be804ea88cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1SimpleResult.html">SimpleResult</a> mysqlpp::Query::execute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute built-up query. </p>
<p>Use one of the <a class="el" href="classmysqlpp_1_1Query.html#a03ee1b9e393d88de946f5be804ea88cf" title="Execute built-up query. ">execute()</a> overloads if you don't expect the server to return a result set. For instance, a DELETE query. The returned <a class="el" href="classmysqlpp_1_1SimpleResult.html" title="Holds information about the result of queries that don&#39;t return rows. ">SimpleResult</a> object contains status information from the server, such as whether the query succeeded, and if so how many rows were affected.</p>
<p>This overloaded version of <a class="el" href="classmysqlpp_1_1Query.html#a03ee1b9e393d88de946f5be804ea88cf" title="Execute built-up query. ">execute()</a> simply executes the query that you have built up in the object in some way. (For instance, via the <a class="el" href="classmysqlpp_1_1Query.html#aa91bbb80705fce681f30f32c6df4c0c2" title="Insert a new row. ">insert()</a> method, or by using the object's stream interface.)</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmysqlpp_1_1SimpleResult.html" title="Holds information about the result of queries that don&#39;t return rows. ">SimpleResult</a> status information about the query</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmysqlpp_1_1Query.html#a23057cc385f9645d7d7ef00aecc2c8ba" title="Execute a built-up query. ">exec()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a16c800e645429d558f4295065b1aed73" title="Execute a query that can return a result set. ">store()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a8ba080b7a2f2cd4086fbb374ae86b6e9" title="Execute a query, and store the entire result set in an STL container. ">storein()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a8538e92f55a5536bbf7704d27151ed87" title="Execute a query that can return rows, with access to the rows in sequence. ">use()</a> </dd></dl>

<p>References <a class="el" href="classmysqlpp_1_1Query.html#a17036cdcf4dd7a747b1ba6ee664da048">str()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a622a5b10c49ab798f7f5481ff38a55d1">template_defaults</a>.</p>

<p>Referenced by <a class="el" href="classmysqlpp_1_1Transaction.html#a109bd0f1d70b6ff69cf3abccf7eea8f8">mysqlpp::Transaction::commit()</a>, <a class="el" href="classmysqlpp_1_1Query.html#aaf36ce2e47a62fae2cc507a7750d1ecd">execute()</a>, <a class="el" href="classmysqlpp_1_1Transaction.html#a000e4f0882139eb8470f7472ca14a24e">mysqlpp::Transaction::rollback()</a>, and <a class="el" href="classmysqlpp_1_1Transaction.html#a5472100c371746d23311bbd74067c5dc">mysqlpp::Transaction::Transaction()</a>.</p>

</div>
</div>
<a class="anchor" id="aaf36ce2e47a62fae2cc507a7750d1ecd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1SimpleResult.html">SimpleResult</a> mysqlpp::Query::execute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute template query using given parameters. </p>
<p>This method should only be used by code that doesn't know, at compile time, how many parameters it will have. This is useful within the library, and also for code that builds template queries dynamically, at run time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>parameters to use in the template query. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classmysqlpp_1_1Query.html#a03ee1b9e393d88de946f5be804ea88cf">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a17036cdcf4dd7a747b1ba6ee664da048">str()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a622a5b10c49ab798f7f5481ff38a55d1">template_defaults</a>.</p>

</div>
</div>
<a class="anchor" id="af2cc737d916e4e1c9fd0392316e5415c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1SimpleResult.html">SimpleResult</a> mysqlpp::Query::execute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a query that returns no rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>if this object is set up as a template query, this is the value to substitute for the first template query parameter; else, it is the SQL query string to execute</td></tr>
  </table>
  </dd>
</dl>
<p>Because <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html" title="Converts many different data types to strings suitable for use in SQL queries. ">SQLTypeAdapter</a> can be initialized from either a C string or a C++ string, this overload accepts query strings in either form. Beware, <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html" title="Converts many different data types to strings suitable for use in SQL queries. ">SQLTypeAdapter</a> also accepts many other data types (this is its <em>raison</em> <em>d'etre</em>), so it will let you write code that compiles but results in bogus SQL queries.</p>
<p>To support template queries, there many more overloads of this type (25 total, by default; see <code>lib/querydef.pl</code>), each taking one more <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html" title="Converts many different data types to strings suitable for use in SQL queries. ">SQLTypeAdapter</a> object than the previous one. See the template query overview above for more about this topic. </p>

<p>References <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html#a00875a645caa82f8014d85b5f906665f">mysqlpp::SQLTypeAdapter::data()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a03ee1b9e393d88de946f5be804ea88cf">execute()</a>, <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html#afed8e311f6481ee92f51d9cb0fe689f5">mysqlpp::SQLTypeAdapter::length()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a622a5b10c49ab798f7f5481ff38a55d1">template_defaults</a>.</p>

</div>
</div>
<a class="anchor" id="a1faab5676c797dac619c6c98dc264e3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1SimpleResult.html">SimpleResult</a> mysqlpp::Query::execute </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute query in a known-length string of characters. This can include null characters. </p>
<p>Executes the query immediately, and returns the results. </p>

<p>References <a class="el" href="classmysqlpp_1_1Query.html#a80d0b71c5cb23f70ebc0d27f0ecc3adc">affected_rows()</a>, <a class="el" href="classmysqlpp_1_1Connection.html#a0d118df40a7bd4bb63e7286b221f7680">mysqlpp::Connection::driver()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a3acf442e091bdfb5344cbe9990f05f3b">errnum()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a24ddaff8ae037c56c1a5aceda34e89c8">error()</a>, <a class="el" href="classmysqlpp_1_1DBDriver.html#aa5ce8af647f93839757a8398a9e106db">mysqlpp::DBDriver::execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a03ee1b9e393d88de946f5be804ea88cf">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#afecef4fce9f76f19ee82ad5a4bece19f">info()</a>, <a class="el" href="classmysqlpp_1_1Query.html#aa15198c894157a099154be69201b5baf">insert_id()</a>, <a class="el" href="classmysqlpp_1_1Query.html#af12740e420c1d61b1d9c2995459a3ce0">reset()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a622a5b10c49ab798f7f5481ff38a55d1">template_defaults</a>, and <a class="el" href="classmysqlpp_1_1OptionalExceptions.html#a6231a5e3fd15fd5ecc4c74785b8c4514">mysqlpp::OptionalExceptions::throw_exceptions()</a>.</p>

</div>
</div>
<a class="anchor" id="a2468c96fcf7ea01ebde250f9e9cd0523"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Function mysqlpp::Query::for_each </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a query, and call a functor for each returned row. </p>
<p>This method wraps a <a class="el" href="classmysqlpp_1_1Query.html#a8538e92f55a5536bbf7704d27151ed87" title="Execute a query that can return rows, with access to the rows in sequence. ">use()</a> query, calling the given functor for every returned row. It is analogous to STL's <a class="el" href="classmysqlpp_1_1Query.html#a2468c96fcf7ea01ebde250f9e9cd0523" title="Execute a query, and call a functor for each returned row. ">for_each()</a> algorithm, but instead of iterating over some range within a container, it iterates over a result set produced by a query.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>the query string </td></tr>
    <tr><td class="paramname">fn</td><td>the functor called for each row </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the passed functor </dd></dl>

<p>References <a class="el" href="classmysqlpp_1_1UseQueryResult.html#ad5392e08b52a64737a6edb966a61d005">mysqlpp::UseQueryResult::fetch_row()</a>.</p>

</div>
</div>
<a class="anchor" id="a1436c089b356ccaeca67d1fd5bbd4280"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Function mysqlpp::Query::for_each </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute the query, and call a functor for each returned row. </p>
<p>Just like <a class="el" href="classmysqlpp_1_1Query.html#a2468c96fcf7ea01ebde250f9e9cd0523" title="Execute a query, and call a functor for each returned row. ">for_each(const SQLTypeAdapter&amp;, Function)</a>, but it uses the query string held by the <a class="el" href="classmysqlpp_1_1Query.html" title="A class for building and executing SQL queries. ">Query</a> object already</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the functor called for each row </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the passed functor </dd></dl>

<p>References <a class="el" href="classmysqlpp_1_1UseQueryResult.html#ad5392e08b52a64737a6edb966a61d005">mysqlpp::UseQueryResult::fetch_row()</a>.</p>

</div>
</div>
<a class="anchor" id="ab9e16f754112ec2f743db10d92059f86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SSQLS , typename Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Function mysqlpp::Query::for_each </td>
          <td>(</td>
          <td class="paramtype">const SSQLS &amp;&#160;</td>
          <td class="paramname"><em>ssqls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run a functor for every row in a table. </p>
<p>Just like <a class="el" href="classmysqlpp_1_1Query.html#a1436c089b356ccaeca67d1fd5bbd4280" title="Execute the query, and call a functor for each returned row. ">for_each(Function)</a>, except that it builds a "select * from TABLE" query using the SQL table name from the SSQLS instance you pass.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ssqls</td><td>the SSQLS instance to get a table name from </td></tr>
    <tr><td class="paramname">fn</td><td>the functor called for each row</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the passed functor </dd></dl>

<p>References <a class="el" href="classmysqlpp_1_1UseQueryResult.html#ad5392e08b52a64737a6edb966a61d005">mysqlpp::UseQueryResult::fetch_row()</a>.</p>

</div>
</div>
<a class="anchor" id="aa91bbb80705fce681f30f32c6df4c0c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1Query.html">Query</a>&amp; mysqlpp::Query::insert </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new row. </p>
<p>This function builds an INSERT SQL query. One uses it with MySQL++'s Specialized SQL Structures mechanism.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>new row</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmysqlpp_1_1Query.html#aa2d5b5aa23b96c600c157718e4ac60b4" title="Insert new row unless there is an existing row that matches on a unique index, in which case we repla...">replace()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a64aa3f8489020795552965c70b515428" title="Replace an existing row&#39;s data with new data. ">update()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a27b148136e317f91aee3a43b3d7b2250"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1Query.html">Query</a>&amp; mysqlpp::Query::insert </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert multiple new rows. </p>
<p>Builds an INSERT SQL query using items from a range within an STL container. Insert the entire contents of the container by using the begin() and end() iterators of the container as parameters to this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator pointing to first element in range to insert </td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing to one past the last element to insert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmysqlpp_1_1Query.html#a9084d8e752601d5663ab145be02ef224" title="Insert multiple new rows using an insert policy to control how the INSERT statements are created usin...">insertfrom()</a>, <a class="el" href="classmysqlpp_1_1Query.html#aa2d5b5aa23b96c600c157718e4ac60b4" title="Insert new row unless there is an existing row that matches on a unique index, in which case we repla...">replace()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a64aa3f8489020795552965c70b515428" title="Replace an existing row&#39;s data with new data. ">update()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa15198c894157a099154be69201b5baf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulonglong mysqlpp::Query::insert_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ID generated for an AUTO_INCREMENT column in the previous INSERT query. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if the previous query did not generate an ID. Use the SQL function LAST_INSERT_ID() if you need the last ID generated by any query, not just the previous one. This applies to stored procedure calls because this function returns the ID generated by the last query, which was a CALL statement, and CALL doesn't generate IDs. You need to use LAST_INSERT_ID() to get the ID in this case. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classmysqlpp_1_1Connection.html#a0d118df40a7bd4bb63e7286b221f7680">mysqlpp::Connection::driver()</a>, and <a class="el" href="classmysqlpp_1_1DBDriver.html#a685cd87d9f8c96e97859277882363b8e">mysqlpp::DBDriver::insert_id()</a>.</p>

<p>Referenced by <a class="el" href="classmysqlpp_1_1Query.html#a1faab5676c797dac619c6c98dc264e3c">execute()</a>.</p>

</div>
</div>
<a class="anchor" id="a9084d8e752601d5663ab145be02ef224"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter , class InsertPolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1Query.html">Query</a>&amp; mysqlpp::Query::insertfrom </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InsertPolicy &amp;&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert multiple new rows using an insert policy to control how the INSERT statements are created using items from an STL container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator pointing to first element in range to insert </td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing to one past the last element to insert </td></tr>
    <tr><td class="paramname">policy</td><td>insert policy object, see <a class="el" href="insertpolicy_8h.html" title="Declares the InsertPolicy classes. ">insertpolicy.h</a> for details</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmysqlpp_1_1Query.html#aa91bbb80705fce681f30f32c6df4c0c2" title="Insert a new row. ">insert()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aeeaff6b3fb94ff4bcad4046a833ee2ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mysqlpp::Query::more_results </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether more results are waiting for a multi-query or stored procedure response. </p>
<p>If this function returns true, you must call <a class="el" href="classmysqlpp_1_1Query.html#a0e22c60aa550675b5e89ab9bbaea7f8e" title="Return next result set, when processing a multi-query. ">store_next()</a> to fetch the next result set before you can execute more queries.</p>
<p>Wraps mysql_more_results() in the MySQL C API. That function only exists in MySQL v4.1 and higher. Therefore, this function always returns false when built against older API libraries.</p>
<dl class="section return"><dt>Returns</dt><dd>true if another result set exists </dd></dl>

<p>References <a class="el" href="classmysqlpp_1_1Connection.html#a0d118df40a7bd4bb63e7286b221f7680">mysqlpp::Connection::driver()</a>, and <a class="el" href="classmysqlpp_1_1DBDriver.html#a7b2168472fbe6ecb93609187001357e7">mysqlpp::DBDriver::more_results()</a>.</p>

</div>
</div>
<a class="anchor" id="a9c2ff95a7cd013758cb1ad9984a7b74e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::Query::operator void * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether the object has experienced an error condition. </p>
<p>Allows for code constructs like this:</p>
<div class="fragment"><div class="line">*       <a class="code" href="classmysqlpp_1_1Query.html#a6c6cbae18ebcb31b6d44e7784d5a3daa">Query</a> q = conn.query();</div>
<div class="line">*       .... <a class="code" href="classmysqlpp_1_1Query.html#a8538e92f55a5536bbf7704d27151ed87">use</a> query <span class="keywordtype">object</span></div>
<div class="line">*       <span class="keywordflow">if</span> (q) {</div>
<div class="line">*           ... no problems in <span class="keyword">using</span> query <span class="keywordtype">object</span></div>
<div class="line">*       }</div>
<div class="line">*       <span class="keywordflow">else</span> {</div>
<div class="line">*           ... an <a class="code" href="classmysqlpp_1_1Query.html#a24ddaff8ae037c56c1a5aceda34e89c8">error</a> has occurred</div>
<div class="line">*       }</div>
<div class="line">*  </div>
</div><!-- fragment --><p>This method returns false if either the <a class="el" href="classmysqlpp_1_1Query.html" title="A class for building and executing SQL queries. ">Query</a> object or its associated <a class="el" href="classmysqlpp_1_1Connection.html" title="Manages the connection to the database server. ">Connection</a> object has seen an error condition since the last operation. </p>

</div>
</div>
<a class="anchor" id="adc5e3d5604dbe48cda5d8d2e64d896f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mysqlpp::Query::operator! </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the query object is not in a bad state. </p>
<p>This just returns the opposite of operator void*(), and is required only because basic_ios defines it, so we have to override it to get Query-specific behavior in code like this:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!query) ... </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a75982ff4f3b5fe603ee6041ed64172ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp; mysqlpp::Query::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign another query's state to this object. </p>
<p>The same caveats apply to this operator as apply to the copy ctor. </p>

<p>References <a class="el" href="classmysqlpp_1_1OptionalExceptions.html#a0273012228b9e6889908a6a93aa47973">mysqlpp::OptionalExceptions::set_exceptions()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a622a5b10c49ab798f7f5481ff38a55d1">template_defaults</a>, and <a class="el" href="classmysqlpp_1_1OptionalExceptions.html#a6231a5e3fd15fd5ecc4c74785b8c4514">mysqlpp::OptionalExceptions::throw_exceptions()</a>.</p>

<p>Referenced by <a class="el" href="classmysqlpp_1_1Query.html#a936b1062bb31b3428ead059a26590b6b">Query()</a>.</p>

</div>
</div>
<a class="anchor" id="a5bfc86346581917cb833ed55ccd4d5b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::Query::parse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Treat the contents of the query string as a template query. </p>
<p>This method sets up the internal structures used by all of the other members that accept template query parameters. See the "Template Queries" chapter in the user manual for more information. </p>

<p>References <a class="el" href="classmysqlpp_1_1Query.html#a17036cdcf4dd7a747b1ba6ee664da048">str()</a>.</p>

</div>
</div>
<a class="anchor" id="aa2d5b5aa23b96c600c157718e4ac60b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1Query.html">Query</a>&amp; mysqlpp::Query::replace </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert new row unless there is an existing row that matches on a unique index, in which case we replace it. </p>
<p>This function builds a REPLACE SQL query. One uses it with MySQL++'s Specialized SQL Structures mechanism.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>new row</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmysqlpp_1_1Query.html#aa91bbb80705fce681f30f32c6df4c0c2" title="Insert a new row. ">insert()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a64aa3f8489020795552965c70b515428" title="Replace an existing row&#39;s data with new data. ">update()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab4359a9dbd99e93ded73d5df5cd244ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1Query.html">Query</a>&amp; mysqlpp::Query::replace </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert multiple new rows, or replace existing ones if there are existing rows that match on key fields. </p>
<p>Builds a REPLACE SQL query using items from a range within an STL container. Insert the entire contents of the container by using the begin() and end() iterators of the container as parameters to this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator pointing to first element in range to insert/replace </td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing to one past the last element to insert/replace</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmysqlpp_1_1Query.html#a9084d8e752601d5663ab145be02ef224" title="Insert multiple new rows using an insert policy to control how the INSERT statements are created usin...">insertfrom()</a>, <a class="el" href="classmysqlpp_1_1Query.html#aa2d5b5aa23b96c600c157718e4ac60b4" title="Insert new row unless there is an existing row that matches on a unique index, in which case we repla...">replace()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a64aa3f8489020795552965c70b515428" title="Replace an existing row&#39;s data with new data. ">update()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7ff065d1b18f3c6141ef57ce9d542837"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter , class InsertPolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1Query.html">Query</a>&amp; mysqlpp::Query::replacefrom </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InsertPolicy &amp;&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace multiple new rows using an insert policy to control how the REPLACE statements are created using items from an STL container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator pointing to first element in range to replace </td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing to one past the last element to replace </td></tr>
    <tr><td class="paramname">policy</td><td>insert policy object, see <a class="el" href="insertpolicy_8h.html" title="Declares the InsertPolicy classes. ">insertpolicy.h</a> for details</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmysqlpp_1_1Query.html#aa91bbb80705fce681f30f32c6df4c0c2" title="Insert a new row. ">insert()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af12740e420c1d61b1d9c2995459a3ce0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::Query::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the query object so that it can be reused. </p>
<p>As of v3.0, <a class="el" href="classmysqlpp_1_1Query.html" title="A class for building and executing SQL queries. ">Query</a> objects auto-reset upon query execution unless you've set it up for making template queries. (It can't auto-reset in that situation, because it would forget the template info.) Therefore, the only time you must call this is if you have a <a class="el" href="classmysqlpp_1_1Query.html" title="A class for building and executing SQL queries. ">Query</a> object set up for making template queries, then want to build queries using one of the other methods. (Static strings, SSQLS, or the stream interface.) </p>

<p>References <a class="el" href="classmysqlpp_1_1SQLQueryParms.html#a15b3fb93546e32b4cbd8015db34ec1e5">mysqlpp::SQLQueryParms::clear()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a622a5b10c49ab798f7f5481ff38a55d1">template_defaults</a>.</p>

<p>Referenced by <a class="el" href="classmysqlpp_1_1Query.html#a985acb52d0a988d1800c8fc4f4c5dc06">exec()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a1faab5676c797dac619c6c98dc264e3c">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a15f991f68505f9a35aed0a03932a1900">store()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#ab00af2e285dbb32eb51de17e567d8b00">use()</a>.</p>

</div>
</div>
<a class="anchor" id="ab02c4ab2f46159d9d45bfd2bbe57e2b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mysqlpp::Query::result_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the most recent result set was empty. </p>
<p>Wraps <a class="el" href="classmysqlpp_1_1DBDriver.html#af56834aa1357f86141b9cdcccf4ff4ce" title="Returns true if the most recent result set was empty. ">DBDriver::result_empty()</a> </p>

<p>References <a class="el" href="classmysqlpp_1_1Connection.html#a0d118df40a7bd4bb63e7286b221f7680">mysqlpp::Connection::driver()</a>, and <a class="el" href="classmysqlpp_1_1DBDriver.html#af56834aa1357f86141b9cdcccf4ff4ce">mysqlpp::DBDriver::result_empty()</a>.</p>

</div>
</div>
<a class="anchor" id="a16c800e645429d558f4295065b1aed73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1StoreQueryResult.html">StoreQueryResult</a> mysqlpp::Query::store </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a query that can return a result set. </p>
<p>Use one of the <a class="el" href="classmysqlpp_1_1Query.html#a16c800e645429d558f4295065b1aed73" title="Execute a query that can return a result set. ">store()</a> overloads to execute a query and retrieve the entire result set into memory. This is useful if you actually need all of the records at once, but if not, consider using one of the <a class="el" href="classmysqlpp_1_1Query.html#a8538e92f55a5536bbf7704d27151ed87" title="Execute a query that can return rows, with access to the rows in sequence. ">use()</a> methods instead, which returns the results one at a time, so they don't allocate as much memory as <a class="el" href="classmysqlpp_1_1Query.html#a16c800e645429d558f4295065b1aed73" title="Execute a query that can return a result set. ">store()</a>.</p>
<p>You must use <a class="el" href="classmysqlpp_1_1Query.html#a16c800e645429d558f4295065b1aed73" title="Execute a query that can return a result set. ">store()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a8ba080b7a2f2cd4086fbb374ae86b6e9" title="Execute a query, and store the entire result set in an STL container. ">storein()</a> or <a class="el" href="classmysqlpp_1_1Query.html#a8538e92f55a5536bbf7704d27151ed87" title="Execute a query that can return rows, with access to the rows in sequence. ">use()</a> for <code>SELECT</code>, <code>SHOW</code>, <code>DESCRIBE</code> and <code>EXPLAIN</code> queries. You can use these functions with other query types, but since they don't return a result set, <a class="el" href="classmysqlpp_1_1Query.html#a23057cc385f9645d7d7ef00aecc2c8ba" title="Execute a built-up query. ">exec()</a> and <a class="el" href="classmysqlpp_1_1Query.html#a03ee1b9e393d88de946f5be804ea88cf" title="Execute built-up query. ">execute()</a> are more efficient.</p>
<p>The name of this method comes from the MySQL C API function it is implemented in terms of, <code>mysql_store_result()</code>.</p>
<p>This function has the same set of overloads as <a class="el" href="classmysqlpp_1_1Query.html#a03ee1b9e393d88de946f5be804ea88cf" title="Execute built-up query. ">execute()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmysqlpp_1_1StoreQueryResult.html" title="StoreQueryResult set type for &quot;store&quot; queries. ">StoreQueryResult</a> object containing entire result set</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmysqlpp_1_1Query.html#a23057cc385f9645d7d7ef00aecc2c8ba" title="Execute a built-up query. ">exec()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a03ee1b9e393d88de946f5be804ea88cf" title="Execute built-up query. ">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a8ba080b7a2f2cd4086fbb374ae86b6e9" title="Execute a query, and store the entire result set in an STL container. ">storein()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a8538e92f55a5536bbf7704d27151ed87" title="Execute a query that can return rows, with access to the rows in sequence. ">use()</a> </dd></dl>

<p>References <a class="el" href="classmysqlpp_1_1Query.html#a17036cdcf4dd7a747b1ba6ee664da048">str()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a622a5b10c49ab798f7f5481ff38a55d1">template_defaults</a>.</p>

<p>Referenced by <a class="el" href="classmysqlpp_1_1Connection.html#a71356d1ca53c988bf9f1e1946e4a7f48">mysqlpp::Connection::count_rows()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a2bcd3c940f936f38bd40396449007d80">store()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a0e22c60aa550675b5e89ab9bbaea7f8e">store_next()</a>.</p>

</div>
</div>
<a class="anchor" id="a2bcd3c940f936f38bd40396449007d80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1StoreQueryResult.html">StoreQueryResult</a> mysqlpp::Query::store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store results from a template query using given parameters. </p>
<p>This method should only be used by code that doesn't know, at compile time, how many parameters it will have. This is useful within the library, and also for code that builds template queries dynamically, at run time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>parameters to use in the template query. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classmysqlpp_1_1Query.html#a16c800e645429d558f4295065b1aed73">store()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a17036cdcf4dd7a747b1ba6ee664da048">str()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a622a5b10c49ab798f7f5481ff38a55d1">template_defaults</a>.</p>

</div>
</div>
<a class="anchor" id="a4531cbffbb15c003ff35c3bbbd3b4397"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1StoreQueryResult.html">StoreQueryResult</a> mysqlpp::Query::store </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a query that can return rows, returning all of the rows in a random-access container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>if this object is set up as a template query, this is the value to substitute for the first template query parameter; else, it is the SQL query string to execute</td></tr>
  </table>
  </dd>
</dl>
<p>Because <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html" title="Converts many different data types to strings suitable for use in SQL queries. ">SQLTypeAdapter</a> can be initialized from either a C string or a C++ string, this overload accepts query strings in either form. Beware, <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html" title="Converts many different data types to strings suitable for use in SQL queries. ">SQLTypeAdapter</a> also accepts many other data types (this is its <em>raison</em> <em>d'etre</em>), so it will let you write code that compiles but results in bogus SQL queries.</p>
<p>To support template queries, there many more overloads of this type (25 total, by default; see <code>lib/querydef.pl</code>), each taking one more <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html" title="Converts many different data types to strings suitable for use in SQL queries. ">SQLTypeAdapter</a> object than the previous one. See the template query overview above for more about this topic. </p>

<p>References <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html#a00875a645caa82f8014d85b5f906665f">mysqlpp::SQLTypeAdapter::data()</a>, <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html#afed8e311f6481ee92f51d9cb0fe689f5">mysqlpp::SQLTypeAdapter::length()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a16c800e645429d558f4295065b1aed73">store()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a622a5b10c49ab798f7f5481ff38a55d1">template_defaults</a>.</p>

</div>
</div>
<a class="anchor" id="a15f991f68505f9a35aed0a03932a1900"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1StoreQueryResult.html">StoreQueryResult</a> mysqlpp::Query::store </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a query that can return rows, returning all of the rows in a random-access container. </p>
<p>This overload is for situations where you have the query in a C string and have its length already. If you want to execute a query in a null-terminated C string or have the query string in some other form, you probably want to call <a class="el" href="classmysqlpp_1_1Query.html#a4531cbffbb15c003ff35c3bbbd3b4397" title="Execute a query that can return rows, returning all of the rows in a random-access container...">store(const SQLTypeAdapter&amp;)</a> instead. <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html" title="Converts many different data types to strings suitable for use in SQL queries. ">SQLTypeAdapter</a> converts from plain C strings and other useful data types implicitly. </p>

<p>References <a class="el" href="classmysqlpp_1_1Connection.html#a0d118df40a7bd4bb63e7286b221f7680">mysqlpp::Connection::driver()</a>, <a class="el" href="classmysqlpp_1_1Connection.html#a3cb1bf601b19dbb87b36bed4590f4214">mysqlpp::Connection::errnum()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a3acf442e091bdfb5344cbe9990f05f3b">errnum()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a24ddaff8ae037c56c1a5aceda34e89c8">error()</a>, <a class="el" href="classmysqlpp_1_1DBDriver.html#aa5ce8af647f93839757a8398a9e106db">mysqlpp::DBDriver::execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#af12740e420c1d61b1d9c2995459a3ce0">reset()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a16c800e645429d558f4295065b1aed73">store()</a>, <a class="el" href="classmysqlpp_1_1DBDriver.html#a2a5e5817177c96b4cd3fd80a74f8ae80">mysqlpp::DBDriver::store_result()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a622a5b10c49ab798f7f5481ff38a55d1">template_defaults</a>, and <a class="el" href="classmysqlpp_1_1OptionalExceptions.html#a6231a5e3fd15fd5ecc4c74785b8c4514">mysqlpp::OptionalExceptions::throw_exceptions()</a>.</p>

</div>
</div>
<a class="anchor" id="ad7c3181bf3e2bc4399a302a60c4a3527"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sequence , typename Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Function mysqlpp::Query::store_if </td>
          <td>(</td>
          <td class="paramtype">Sequence &amp;&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a query, conditionally storing each row in a container. </p>
<p>This method wraps a <a class="el" href="classmysqlpp_1_1Query.html#a8538e92f55a5536bbf7704d27151ed87" title="Execute a query that can return rows, with access to the rows in sequence. ">use()</a> query, calling the given functor for every returned row, and storing the results in the given sequence container if the functor returns true.</p>
<p>This is analogous to the STL copy_if() algorithm, except that the source rows come from a database query instead of another container. (copy_if() isn't a standard STL algorithm, but only due to an oversight by the standardization committee.) This fact may help you to remember the order of the parameters: the container is the destination, the query is the source, and the functor is the predicate; it's just like an STL algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">con</td><td>the destination container; needs a push_back() method </td></tr>
    <tr><td class="paramname">query</td><td>the query string </td></tr>
    <tr><td class="paramname">fn</td><td>the functor called for each row </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the passed functor </dd></dl>

<p>References <a class="el" href="classmysqlpp_1_1UseQueryResult.html#ad5392e08b52a64737a6edb966a61d005">mysqlpp::UseQueryResult::fetch_row()</a>.</p>

</div>
</div>
<a class="anchor" id="a7a044520c6a19e55ad0fbfa4b52ae237"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sequence , class SSQLS , typename Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Function mysqlpp::Query::store_if </td>
          <td>(</td>
          <td class="paramtype">Sequence &amp;&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SSQLS &amp;&#160;</td>
          <td class="paramname"><em>ssqls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pulls every row in a table, conditionally storing each one in a container. </p>
<p>Just like <a class="el" href="classmysqlpp_1_1Query.html#ad7c3181bf3e2bc4399a302a60c4a3527" title="Execute a query, conditionally storing each row in a container. ">store_if(Sequence&amp;, const SQLTypeAdapter&amp;, Function)</a>, but it uses the SSQLS instance to construct a "select * from TABLE" query, using the table name field in the SSQLS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">con</td><td>the destination container; needs a push_back() method </td></tr>
    <tr><td class="paramname">ssqls</td><td>the SSQLS instance to get a table name from </td></tr>
    <tr><td class="paramname">fn</td><td>the functor called for each row </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the passed functor </dd></dl>

<p>References <a class="el" href="classmysqlpp_1_1UseQueryResult.html#ad5392e08b52a64737a6edb966a61d005">mysqlpp::UseQueryResult::fetch_row()</a>.</p>

</div>
</div>
<a class="anchor" id="a6d6e8dcd8e1538017c11ac02b2846ce2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sequence , typename Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Function mysqlpp::Query::store_if </td>
          <td>(</td>
          <td class="paramtype">Sequence &amp;&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute the query, conditionally storing each row in a container. </p>
<p>Just like <a class="el" href="classmysqlpp_1_1Query.html#ad7c3181bf3e2bc4399a302a60c4a3527" title="Execute a query, conditionally storing each row in a container. ">store_if(Sequence&amp;, const SQLTypeAdapter&amp;, Function)</a>, but it uses the query string held by the <a class="el" href="classmysqlpp_1_1Query.html" title="A class for building and executing SQL queries. ">Query</a> object already</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">con</td><td>the destination container; needs a push_back() method </td></tr>
    <tr><td class="paramname">fn</td><td>the functor called for each row </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the passed functor </dd></dl>

<p>References <a class="el" href="classmysqlpp_1_1UseQueryResult.html#ad5392e08b52a64737a6edb966a61d005">mysqlpp::UseQueryResult::fetch_row()</a>.</p>

</div>
</div>
<a class="anchor" id="a0e22c60aa550675b5e89ab9bbaea7f8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1StoreQueryResult.html">StoreQueryResult</a> mysqlpp::Query::store_next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return next result set, when processing a multi-query. </p>
<p>There are two cases where you'd use this function instead of the regular <a class="el" href="classmysqlpp_1_1Query.html#a16c800e645429d558f4295065b1aed73" title="Execute a query that can return a result set. ">store()</a> functions.</p>
<p>First, when handling the result of executing multiple queries at once. (See <a href="http://dev.mysql.com/doc/mysql/en/c-api-multiple-queries.html">this page</a> in the MySQL documentation for details.)</p>
<p>Second, when calling a stored procedure, MySQL can return the result as a set of results.</p>
<p>In either case, you must consume all results before making another MySQL query, even if you don't care about the remaining results or result sets.</p>
<p>As the MySQL documentation points out, you must set the MYSQL_OPTION_MULTI_STATEMENTS_ON flag on the connection in order to use this feature. See <a class="el" href="classmysqlpp_1_1Connection.html#a266f69b0e8d9d588e8cc6c5a2a897b87" title="Sets a connection option. ">Connection::set_option()</a>.</p>
<p>Multi-queries only exist in MySQL v4.1 and higher. Therefore, this function just wraps <a class="el" href="classmysqlpp_1_1Query.html#a16c800e645429d558f4295065b1aed73" title="Execute a query that can return a result set. ">store()</a> when built against older API libraries.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmysqlpp_1_1StoreQueryResult.html" title="StoreQueryResult set type for &quot;store&quot; queries. ">StoreQueryResult</a> object containing the next result set. </dd></dl>

<p>References <a class="el" href="classmysqlpp_1_1Connection.html#a0d118df40a7bd4bb63e7286b221f7680">mysqlpp::Connection::driver()</a>, <a class="el" href="classmysqlpp_1_1Connection.html#a3cb1bf601b19dbb87b36bed4590f4214">mysqlpp::Connection::errnum()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a3acf442e091bdfb5344cbe9990f05f3b">errnum()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a24ddaff8ae037c56c1a5aceda34e89c8">error()</a>, <a class="el" href="classmysqlpp_1_1DBDriver.html#abaa7e674055e1e1715c7ccb0f515fedb">mysqlpp::DBDriver::next_result()</a>, <a class="el" href="classmysqlpp_1_1DBDriver.html#a0275cada4dbb299404e02bffc113addaa49d5639a52fa99f7c926c0dc4f047eda">mysqlpp::DBDriver::nr_error</a>, <a class="el" href="classmysqlpp_1_1DBDriver.html#a0275cada4dbb299404e02bffc113addaa17d7be6c71fbd797813ef09ae89eb421">mysqlpp::DBDriver::nr_more_results</a>, <a class="el" href="classmysqlpp_1_1Query.html#a16c800e645429d558f4295065b1aed73">store()</a>, <a class="el" href="classmysqlpp_1_1DBDriver.html#a2a5e5817177c96b4cd3fd80a74f8ae80">mysqlpp::DBDriver::store_result()</a>, and <a class="el" href="classmysqlpp_1_1OptionalExceptions.html#a6231a5e3fd15fd5ecc4c74785b8c4514">mysqlpp::OptionalExceptions::throw_exceptions()</a>.</p>

</div>
</div>
<a class="anchor" id="a8ba080b7a2f2cd4086fbb374ae86b6e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::Query::storein </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>con</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a query, and store the entire result set in an STL container. </p>
<p>This is a set of specialized template functions that call either <a class="el" href="classmysqlpp_1_1Query.html#a948387c9f15db2837e7aad557c955424" title="Execute a query, storing the result set in an STL sequence container. ">storein_sequence()</a> or <a class="el" href="classmysqlpp_1_1Query.html#aef7fb34235a244fd3d92e62fc026946f" title="Execute a query, storing the result set in an STL associative container. ">storein_set()</a>, depending on the type of container you pass it. It understands <code>std::vector</code>, <code>deque</code>, <code>list</code>, <code>slist</code> (a common C++ library extension), <code>set</code>, and <code>multiset</code>.</p>
<p>Like the functions it wraps, this is actually an overloaded set of functions. See the other functions' documentation for details.</p>
<p>Use this function if you think you might someday switch your program from using a set-associative container to a sequence container for storing result sets, or vice versa.</p>
<p>See <a class="el" href="classmysqlpp_1_1Query.html#a23057cc385f9645d7d7ef00aecc2c8ba" title="Execute a built-up query. ">exec()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a03ee1b9e393d88de946f5be804ea88cf" title="Execute built-up query. ">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a16c800e645429d558f4295065b1aed73" title="Execute a query that can return a result set. ">store()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a8538e92f55a5536bbf7704d27151ed87" title="Execute a query that can return rows, with access to the rows in sequence. ">use()</a> for alternative query execution mechanisms. </p>

</div>
</div>
<a class="anchor" id="a461d17d9db64dd040339cbff070ea02c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::Query::storein </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store template query results into a container. </p>
<p>This method is not intended to be used directly. It is part of the call chain in processing calls to one of the many <a class="el" href="classmysqlpp_1_1Query.html#a8ba080b7a2f2cd4086fbb374ae86b6e9" title="Execute a query, and store the entire result set in an STL container. ">storein()</a> overloads that take a container and one or more <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html" title="Converts many different data types to strings suitable for use in SQL queries. ">SQLTypeAdapter</a> parameters. </p>

</div>
</div>
<a class="anchor" id="a948387c9f15db2837e7aad557c955424"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::Query::storein_sequence </td>
          <td>(</td>
          <td class="paramtype">Sequence &amp;&#160;</td>
          <td class="paramname"><em>con</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a query, storing the result set in an STL sequence container. </p>
<p>This function works much like <a class="el" href="classmysqlpp_1_1Query.html#a16c800e645429d558f4295065b1aed73" title="Execute a query that can return a result set. ">store()</a> from the caller's perspective, because it returns the entire result set at once. It's actually implemented in terms of <a class="el" href="classmysqlpp_1_1Query.html#a8538e92f55a5536bbf7704d27151ed87" title="Execute a query that can return rows, with access to the rows in sequence. ">use()</a>, however, so that memory for the result set doesn't need to be allocated twice.</p>
<p>There are many overloads for this function, pretty much the same as for <a class="el" href="classmysqlpp_1_1Query.html#a03ee1b9e393d88de946f5be804ea88cf" title="Execute built-up query. ">execute()</a>, except that there is a Container parameter at the front of the list. So, you can pass a container and a query string, or a container and template query parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">con</td><td>any STL sequence container, such as <code>std::vector</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmysqlpp_1_1Query.html#a23057cc385f9645d7d7ef00aecc2c8ba" title="Execute a built-up query. ">exec()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a03ee1b9e393d88de946f5be804ea88cf" title="Execute built-up query. ">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a16c800e645429d558f4295065b1aed73" title="Execute a query that can return a result set. ">store()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a8538e92f55a5536bbf7704d27151ed87" title="Execute a query that can return rows, with access to the rows in sequence. ">use()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2fa1ef7235bee641ae4a42a4944fa69c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::Query::storein_sequence </td>
          <td>(</td>
          <td class="paramtype">Sequence &amp;&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a query, storing the result rows in an STL sequence container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">con</td><td>the container to store the results in</td></tr>
    <tr><td class="paramname">s</td><td>if <a class="el" href="classmysqlpp_1_1Query.html" title="A class for building and executing SQL queries. ">Query</a> is set up as a template query, this is the value to substitute for the first template query parameter; else, the SQL query string</td></tr>
  </table>
  </dd>
</dl>
<p>There many more overloads of this type (25 total, by default; see <code>lib/querydef.pl</code>), each taking one more <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html" title="Converts many different data types to strings suitable for use in SQL queries. ">SQLTypeAdapter</a> object than the previous one. See the template query overview above for more about this topic. </p>

</div>
</div>
<a class="anchor" id="a1b378e41e2de26cb0f16ca004c116760"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Seq &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::Query::storein_sequence </td>
          <td>(</td>
          <td class="paramtype">Seq &amp;&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute template query using given parameters, storing the results in a sequence type container. </p>
<p>This method should only be used by code that doesn't know, at compile time, how many parameters it will have. This is useful within the library, and also for code that builds template queries dynamically, at run time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">con</td><td>container that will receive the results </td></tr>
    <tr><td class="paramname">p</td><td>parameters to use in the template query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef7fb34235a244fd3d92e62fc026946f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Set &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::Query::storein_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1Set.html">Set</a> &amp;&#160;</td>
          <td class="paramname"><em>con</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a query, storing the result set in an STL associative container. </p>
<p>The same thing as <a class="el" href="classmysqlpp_1_1Query.html#a948387c9f15db2837e7aad557c955424" title="Execute a query, storing the result set in an STL sequence container. ">storein_sequence()</a>, except that it's used with associative STL containers, such as <code>std::set</code>. Other than that detail, that method's comments apply equally well to this one. </p>

</div>
</div>
<a class="anchor" id="af82a6e6f875c8d1834ac4e56979969bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Set &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::Query::storein_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1Set.html">Set</a> &amp;&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a query, storing the result rows in an STL set-associative container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">con</td><td>the container to store the results in</td></tr>
    <tr><td class="paramname">s</td><td>if <a class="el" href="classmysqlpp_1_1Query.html" title="A class for building and executing SQL queries. ">Query</a> is set up as a template query, this is the value to substitute for the first template query parameter; else, the SQL query string</td></tr>
  </table>
  </dd>
</dl>
<p>There many more overloads of this type (25 total, by default; see <code>lib/querydef.pl</code>), each taking one more <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html" title="Converts many different data types to strings suitable for use in SQL queries. ">SQLTypeAdapter</a> object than the previous one. See the template query overview above for more about this topic. </p>

</div>
</div>
<a class="anchor" id="af207b0559f75833bbf38e670dc217978"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Set &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::Query::storein_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1Set.html">Set</a> &amp;&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute template query using given parameters, storing the results in a set type container. </p>
<p>This method should only be used by code that doesn't know, at compile time, how many parameters it will have. This is useful within the library, and also for code that builds template queries dynamically, at run time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">con</td><td>container that will receive the results </td></tr>
    <tr><td class="paramname">p</td><td>parameters to use in the template query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7fa8d56bd3d8a1bd3b5403665dbf6c8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mysqlpp::Query::str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;&#160;</td>
          <td class="paramname"><em>arg0</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get built query as a C++ string with template query parameter substitution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg0</td><td>the value to substitute for the first template query parameter; because <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html" title="Converts many different data types to strings suitable for use in SQL queries. ">SQLTypeAdapter</a> implicitly converts from many different data types, this method is very flexible in what it accepts as a parameter. You shouldn't have to use the <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html" title="Converts many different data types to strings suitable for use in SQL queries. ">SQLTypeAdapter</a> data type directly in your code.</td></tr>
  </table>
  </dd>
</dl>
<p>There many more overloads of this type (25 total, by default; see <code>lib/querydef.pl</code>), each taking one more <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html" title="Converts many different data types to strings suitable for use in SQL queries. ">SQLTypeAdapter</a> object than the previous one. See the template query overview above for more about this topic. </p>

</div>
</div>
<a class="anchor" id="ac93d201c91a7e0b9056e8cac33a38f7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mysqlpp::Query::str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get built query as a null-terminated C++ string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>template query parameters to use, overriding the ones this object holds, if any </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64aa3f8489020795552965c70b515428"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1Query.html">Query</a>&amp; mysqlpp::Query::update </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace an existing row's data with new data. </p>
<p>This function builds an UPDATE SQL query using the new row data for the SET clause, and the old row data for the WHERE clause. One uses it with MySQL++'s Specialized SQL Structures mechanism.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>old row </td></tr>
    <tr><td class="paramname">n</td><td>new row</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmysqlpp_1_1Query.html#aa91bbb80705fce681f30f32c6df4c0c2" title="Insert a new row. ">insert()</a>, <a class="el" href="classmysqlpp_1_1Query.html#aa2d5b5aa23b96c600c157718e4ac60b4" title="Insert new row unless there is an existing row that matches on a unique index, in which case we repla...">replace()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8538e92f55a5536bbf7704d27151ed87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1UseQueryResult.html">UseQueryResult</a> mysqlpp::Query::use </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a query that can return rows, with access to the rows in sequence. </p>
<p>Use one of the <a class="el" href="classmysqlpp_1_1Query.html#a8538e92f55a5536bbf7704d27151ed87" title="Execute a query that can return rows, with access to the rows in sequence. ">use()</a> overloads if memory efficiency is important. They return an object that can walk through the result records one by one, without fetching the entire result set from the server. This is superior to <a class="el" href="classmysqlpp_1_1Query.html#a16c800e645429d558f4295065b1aed73" title="Execute a query that can return a result set. ">store()</a> when there are a large number of results; <a class="el" href="classmysqlpp_1_1Query.html#a16c800e645429d558f4295065b1aed73" title="Execute a query that can return a result set. ">store()</a> would have to allocate a large block of memory to hold all those records, which could cause problems.</p>
<p>A potential downside of this method is that MySQL database resources are tied up until the result set is completely consumed. Do your best to walk through the result set as expeditiously as possible.</p>
<p>The name of this method comes from the MySQL C API function that initiates the retrieval process, <code>mysql_use_result()</code>. This method is implemented in terms of that function.</p>
<p>This function has the same set of overloads as <a class="el" href="classmysqlpp_1_1Query.html#a03ee1b9e393d88de946f5be804ea88cf" title="Execute built-up query. ">execute()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmysqlpp_1_1UseQueryResult.html" title="StoreQueryResult set type for &quot;use&quot; queries. ">UseQueryResult</a> object that can walk through result set serially</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmysqlpp_1_1Query.html#a23057cc385f9645d7d7ef00aecc2c8ba" title="Execute a built-up query. ">exec()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a03ee1b9e393d88de946f5be804ea88cf" title="Execute built-up query. ">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a16c800e645429d558f4295065b1aed73" title="Execute a query that can return a result set. ">store()</a> and <a class="el" href="classmysqlpp_1_1Query.html#a8ba080b7a2f2cd4086fbb374ae86b6e9" title="Execute a query, and store the entire result set in an STL container. ">storein()</a> </dd></dl>

<p>References <a class="el" href="classmysqlpp_1_1Query.html#a17036cdcf4dd7a747b1ba6ee664da048">str()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a622a5b10c49ab798f7f5481ff38a55d1">template_defaults</a>.</p>

<p>Referenced by <a class="el" href="classmysqlpp_1_1Query.html#a66040c8c0071b50b043e8031309f7852">use()</a>.</p>

</div>
</div>
<a class="anchor" id="a66040c8c0071b50b043e8031309f7852"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1UseQueryResult.html">UseQueryResult</a> mysqlpp::Query::use </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a template query that can return rows, with access to the rows in sequence. </p>
<p>This method should only be used by code that doesn't know, at compile time, how many parameters it will have. This is useful within the library, and also for code that builds template queries dynamically, at run time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>parameters to use in the template query. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classmysqlpp_1_1Query.html#a17036cdcf4dd7a747b1ba6ee664da048">str()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a622a5b10c49ab798f7f5481ff38a55d1">template_defaults</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a8538e92f55a5536bbf7704d27151ed87">use()</a>.</p>

</div>
</div>
<a class="anchor" id="afe90361bc4f17f78c11857d32538dabe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1UseQueryResult.html">UseQueryResult</a> mysqlpp::Query::use </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a query that can return rows, with access to the rows in sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>if this object is set up as a template query, this is the value to substitute for the first template query parameter; else, it is the SQL query string to execute</td></tr>
  </table>
  </dd>
</dl>
<p>Because <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html" title="Converts many different data types to strings suitable for use in SQL queries. ">SQLTypeAdapter</a> can be initialized from either a C string or a C++ string, this overload accepts query strings in either form. Beware, <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html" title="Converts many different data types to strings suitable for use in SQL queries. ">SQLTypeAdapter</a> also accepts many other data types (this is its <em>raison</em> <em>d'etre</em>), so it will let you write code that compiles but results in bogus SQL queries.</p>
<p>To support template queries, there many more overloads of this type (25 total, by default; see <code>lib/querydef.pl</code>), each taking one more <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html" title="Converts many different data types to strings suitable for use in SQL queries. ">SQLTypeAdapter</a> object than the previous one. See the template query overview above for more about this topic. </p>

<p>References <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html#a00875a645caa82f8014d85b5f906665f">mysqlpp::SQLTypeAdapter::data()</a>, <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html#afed8e311f6481ee92f51d9cb0fe689f5">mysqlpp::SQLTypeAdapter::length()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a622a5b10c49ab798f7f5481ff38a55d1">template_defaults</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a8538e92f55a5536bbf7704d27151ed87">use()</a>.</p>

</div>
</div>
<a class="anchor" id="ab00af2e285dbb32eb51de17e567d8b00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1UseQueryResult.html">UseQueryResult</a> mysqlpp::Query::use </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a query that can return rows, with access to the rows in sequence. </p>
<p>This overload is for situations where you have the query in a C string and have its length already. If you want to execute a query in a null-terminated C string or have the query string in some other form, you probably want to call <a class="el" href="classmysqlpp_1_1Query.html#afe90361bc4f17f78c11857d32538dabe" title="Execute a query that can return rows, with access to the rows in sequence. ">use(const SQLTypeAdapter&amp;)</a> instead. <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html" title="Converts many different data types to strings suitable for use in SQL queries. ">SQLTypeAdapter</a> converts from plain C strings and other useful data types implicitly. </p>

<p>References <a class="el" href="classmysqlpp_1_1Connection.html#a0d118df40a7bd4bb63e7286b221f7680">mysqlpp::Connection::driver()</a>, <a class="el" href="classmysqlpp_1_1Connection.html#a3cb1bf601b19dbb87b36bed4590f4214">mysqlpp::Connection::errnum()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a3acf442e091bdfb5344cbe9990f05f3b">errnum()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a24ddaff8ae037c56c1a5aceda34e89c8">error()</a>, <a class="el" href="classmysqlpp_1_1DBDriver.html#aa5ce8af647f93839757a8398a9e106db">mysqlpp::DBDriver::execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#af12740e420c1d61b1d9c2995459a3ce0">reset()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a622a5b10c49ab798f7f5481ff38a55d1">template_defaults</a>, <a class="el" href="classmysqlpp_1_1OptionalExceptions.html#a6231a5e3fd15fd5ecc4c74785b8c4514">mysqlpp::OptionalExceptions::throw_exceptions()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a8538e92f55a5536bbf7704d27151ed87">use()</a>, and <a class="el" href="classmysqlpp_1_1DBDriver.html#adeb6b2f834cccc051d3b39c8017c1166">mysqlpp::DBDriver::use_result()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a622a5b10c49ab798f7f5481ff38a55d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> mysqlpp::Query::template_defaults</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default template parameters. </p>
<p>Used for filling in parameterized queries. </p>

<p>Referenced by <a class="el" href="classmysqlpp_1_1Query.html#a03ee1b9e393d88de946f5be804ea88cf">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a75982ff4f3b5fe603ee6041ed64172ce">operator=()</a>, <a class="el" href="classmysqlpp_1_1Query.html#af12740e420c1d61b1d9c2995459a3ce0">reset()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a16c800e645429d558f4295065b1aed73">store()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a8538e92f55a5536bbf7704d27151ed87">use()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="query_8h_source.html">query.h</a></li>
<li>query.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 18 2015 18:55:03 for MySQL++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
